=pod

=head1 NAME

dmaster - Manage continuously running processes

=head1 SYNOPSIS

dmaster

=head1 DESCRIPTION

Daemon master.
Start programs defined in B<daemontab> file.
Restart them when ended.

Re-read the B<daemontab> file on B<HUP> signal,
stops processes which are no longer in it (or I<ID> changed) with SIGTERM signal,
and starts new ones.
Those daemons whose I<COMMAND> I<ARGS> changed, are not restarted automatically.

Automatically respawn a daemon when it exits.
If a daemon exits too often, suppress it a little while.
Default parameters: at most 5 spawns in 2 sec, hold up for 10 sec.

=head1 FILES

=over 4

=item F</etc/daemontab>

Format is I<ID> I<COMMAND> I<ARGS>, delimited by any amount of space/tab, one line per each.
I<ID> is an arbitrary word choosed by the user, to identify daemon commands across reloads.
Command arguments may enclosed in double quotes (C<">), but not part of the argument. See:

 d1 my-daemon --param="foo bar"

is invalid (parsed as 2 parameters: C<--param="foo> and C<bar"> with dangling quotes).

 d1 my-daemon "--param=foo bar"

is what you want.

It's not recommended to write complex scripts directly in daemontab.
Put them in F</etc/daemons> directory instead.

=item F</var/run/dmaster.sock>

dmaster(1) listens on a Unix Domain socket (see unix(7)).
When a client connects, internal state is dumped on the socket
in B<Single Value per Line with Hierarchical Keys> format.

Internal state includes all started daemon's B<PIDFD>,
which may be copied by an other program by pidfd_getfd(2),
in order to reliably send signals to it.
After the internal state dump is closed by a line containing a lone C<END>,
it reads one line on the management socket.
Currently you can not control dmaster(1) this way (use signals for this, see L</SIGNALS>),
but while it waits for that one line, does not do anything,
so it's time for the management client side to call pidfd_getfd(2)
to reliably copy the PIDFD representing a given daemon process.

B<Note>, this also means that daemon management is paused until
normal operation is resumed by sending a newline on the management socket.
Due to this potential DoS vector, management socket is chmod(2) to 0660.

=item F</var/run/shm/dmaster.state>

Dump internal state to it.
See USR1 signal below.

=back

=head1 SIGNALS

=over 4

=item USR1

Write internal state into F</var/run/shm/dmaster.state> file.

=item TERM, INT

Terminate managed daemons, always with one B<TERM> signal each,
wait for all of them to exit, then exit dmaster(1) itself.
If a daemon is a process group leader (become on its own or started via setpgrp(1)), sends the signal to the whole process group at once.

=item HUP

Re-read B<daemontab>, stop daemons which are disappeared and start new ones.
Leave others running.

=back

=head1 ENVIRONMENT

=over 4

=item XDG_CONFIG_HOME

Where to find C<daemontab>.
Default is F</etc>.

=item XDG_CACHE_HOME

Where to create F<dmaster.sock>
Default is F</var/run>.

=item DAEMONS_RESPAWN_BURST_PERIOD

Measure this much time (seconds) to detect respawn-burst.

=item DAEMONS_RESPAWN_BURST_LIMIT

If a daemon respawns this many times within DAEMONS_RESPAWN_BURST_PERIOD,
consider it a respawn-burst, and hold it back a while.

=item DAEMONS_RESPAWN_BURST_HOLD

How much time (seconds) to wait before starting a daemon
after a respawn-burst.

=back

=head1 EXAMPLE INSTALLATION

Put this in your inittab(5):

 dm:2345:respawn:loggerexec daemon dmaster /sbin/dmaster

This one removes the socket file in case of it's left there:

 dm:2345:respawn:multicmd -d -- rm /var/run/dmaster.sock -- loggerexec daemon dmaster dmaster

May use the default (although a bit confusing) semicolon multicmd(1) delimiter if your init(1) supports the "at" mark (C<@>) syntax:

 dm:2345:respawn:@multicmd rm /var/run/dmaster.sock ; loggerexec daemon dmaster dmaster

Don't forget to place this inittab(5) entry above any entry with a B<wait> action.

=head1 SEE ALSO

supervisor(1), supervise(8), daemon(1), runit(1), L<sinit|https://core.suckless.org/sinit/>, setpgrp(1)

