#!/usr/bin/env perl

=pod

=head1 NAME

td-filter - Show only those records from the input tabular data stream which match to the conditions.

=head1 USAGE

td-filter [<OPTIONS>] [--] <COLUMN> <OPERATOR> <R-VALUE> [<COLUMN> <OPERATOR> <R-VALUE> [...]]

td-filter [<OPTIONS>] --perl <EXPR>

=head1 DESCRIPTION

Pass through those records which match at least one of the conditions (inclusive OR).
You may put together conditions conjunctively (AND) by chaining multiple td-filter commands in the pipe.
Example:

  td-filter NAME eq john NAME eq jacob | tr-filter AGE -gt 18

This gives the records with either john or jacob, and all of them will be above 18.

td-filter(1) evaluates the Perl expression in the second form and passes through only
if the result is true-ish in Perl (non zero, non empty string, etc).
Each field's value is in @F by index, and in %F by column name.
You can implement more complex conditions in this way.

=head1 OPTIONS

=over 4

=item -H, --no--header

do not show headers

=item -h, --header

show headers (default)

=item -i, --ignore-nonexisting-columns

do not treat non-existing (missing or typo) column names as failure

=item -w, --warn-nonexisting-columns

only show warning on non-existing (missing or type) column names, but don't fail

=back

=head1 OPERATORS

These operators are supported, semantics are the same as in Perl, see perlop(1).

 == != <= >= < > =~ !~ eq ne gt lt

For your convenience, not to bother with escaping, you may also use these operators as alternatives to the canonical ones above:

-eq : numerical equal to

-ne : numerical not equal to

<>  : numerical not equal to

-gt : numerical greater than

-ge : numerical greater or equal

-lt : numerical less than

-le : numerical less or equal

match : regexp match

notmatch : negated regexp match

=head1 CAVEATS

<R-VALUE> does not need quoting or escaping.
If there is no <COLUMN> column in the input data, it's silently considered empty.

=cut

do '/usr/lib/tool/perl5/tabdata/common.pl' or die "$@";

@Filter = ();
$Expr = undef;

%operator_alias = (
	'<>',  '!=',
	'-ne', '!=',
	'-eq', '==',
	'-gt', '>',
	'-lt', '<',
	'-ge', '>=',
	'-le', '<=',
	'notmatch', '!~',
	'match', '=~',
);

if($ARGV[0] eq '--perl')
{
	shift @ARGV;
	die "$0: missing Perl expression\n" unless @ARGV;
	$Expr = join ';', @ARGV;
}
else
{
	while(scalar @ARGV)
	{
		my $column = shift @ARGV;
		my $operator = shift @ARGV or die "$0: missing operator for: $column\n";
		my $rvalue = shift @ARGV or die "$0: missing r-value for: $column $operator\n";
		
		# operator aliases
		$operator = $operator_alias{$operator} if exists $operator_alias{$operator};
		
		unless($operator ~~ [qw/== != <= >= < > =~ !~ eq ne gt lt/])
		{
			die "$0: unknown operator: $operator\n";
		}
		
		push @Filter, {'field'=>$column, 'operator'=>$operator, 'value'=>$rvalue,};
	}
}

process_header(scalar <STDIN>);

if(not defined $Expr)
{
	for my $filter (@Filter)
	{
		my $colname = $filter->{'field'};
		if(not exists $Header{$colname})
		{
			warn "$0: $colname: no such column\n" if $OptWarnBadColumnNames;
			exit 3 if $OptFailBadColumnNames;
		}
	}
}

if($OptShowHeader)
{
	print $HeaderLine.$/;
}

while($line = <STDIN>)
{
	chomp $line;
	
	@Field = split $FS, $line;
	
	if(defined $Expr)
	{
		my @F = @Field;
		my %F = map {$_=>$Field[$Header{$_}]} keys %Header;
		$pass = eval $Expr;
		warn $@ if $@;
	}
	else
	{
		$pass = 0;
		
		for my $filter (@Filter)
		{
			my $left_data = exists $Header{$filter->{'field'}} ? $Field[$Header{$filter->{'field'}}] : '';
			my $right_data = $filter->{'value'};
			my $operator = $filter->{'operator'};
			my $left_code = '$left_data';
			my $right_code = '$right_data';
			$right_code = "/$right_code/" if $operator ~~ ['=~', '!~'];
			if(eval "$left_code $operator $right_code")
			{
				$pass = 1;
				last;
			}
		}
	}
	
	if($pass)
	{
		print $line.$/;
	}
}
