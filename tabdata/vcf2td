#!/usr/bin/env perl

=pod

=head1 NAME

vcf2td - Transform VCF to tabular data format.

=head1 OPTIONS

=over 4

=item -C I<COLUMN> -C I<COLUMN> ...

Predefine columns.
Useful if the first record does not contain all fields
which are otherwise occur in the whole data stream.
By default, vcf2td(1) recognize fields which are in the first record in the VCF input,
does not read ahead more records before sending the header.

=item -i, --ignore-non-existing-columns

Don't fail and don't warn when ecountering new field names.

Tabular data format declares all of the field names in the column headers,
so it can not introduce new columns later on in the data stream
(unless some records were buffered which are not currently).
However in VCF, each record may have fields different from the first record.
That's why vcf2td(1) fails itself by default
if it encounters a field it can not convert to tabular.

=item -w, --warn-non-existing-columns

Only warns on new fields, but don't fail.

=back

=cut


use Data::Dumper;
use Encode;
use MIME::QuotedPrint;
use Switch;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';
do '/usr/lib/tool/perl5/tabdata/common.pl' or die "$@";

@columns = @OptPredefColumns;
@warned_fields = ();
%record = ();
$RN = 0;

while(<STDIN>)
{
	s/\r?\n//;
	
	if(my($field, $data) = /^(.+?):(.*)$/)
	{
		my($field_name, @params) = split /;/, $field;
		my %param = map {split /=/, $_, 2} @params;
		
		if(not $field_name ~~ @columns)
		{
			if(not $field_name ~~ [qw/BEGIN VERSION END/])
			{
				if($RN == 0)
				{
					push @columns, $field_name 
				}
				else
				{
					unless($field_name ~~ @warned_fields)
					{
						warn "$0: column not defined: $field_name\n" if $OptWarnBadColumnNames;
						push @warned_fields, $field_name;
					}
					die if $OptFailBadColumnNames;
					next;
				}
			}
		}
		
		switch($param{'ENCODING'})
		{
			case('QUOTED-PRINTABLE') { $data = decode_qp($data); }
			case(undef) { 1; }
			else { die "$0: unknown encoding: $param{'ENCODING'}, line $., record $RN\n"; }
		}
		
		if($field_name eq 'N')
		{
			my ($family_name, $given_name, $middle_name, $prefixes) = split /;/, $data;
			$record{'N.family'} = $family_name;
			$record{'N.given'} = $given_name;
			$record{'N.middle'} = $middle_name;
			$record{'N.prefixes'} = $prefixes;
			
			$data =~ s/;+/;/g;
			$data =~ s/;$//;
			$data =~ s/^;//;
		}
		
		$record{$field_name} = $data;
		
		if($field_name eq 'END')
		{
			if($RN == 0)
			{
				print join($FS, map {escape_tabdata($_)} @columns) . $RS;
			}
			
			print join($FS, map {escape_tabdata($record{$_})} @columns) . $RS;
			
			%record = ();
			$RN++;
			next;
		}
	}
}
