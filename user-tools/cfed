#!/usr/bin/env perl

=pod

=head1 NAME

cfed - Command File-Editor - Edit text files by commands directly from shell

=head1 SYNOPSIS

 cfed [<OPTIONS>] <INSTRUCTIONS>

=head1 DESCRIPTION

Edit files by giving editor commands like shell commands.
Sematics are similar to well known text editors:
open file, move cursor, type in text, search and replace, select, copy,
paste, ...

May open multiple files.
Always one file is in the foreground.
All opened files has a cursor position at which most commands are
applied.

Files also have several marks which you can set or refer to in
C<select> or C<goto> commands.
A special pair of marks is SELECTION-START and SELECTION-END which
pins the currently selected text for you.

You have one clipboard.

=head1 OPTIONS

=over 4

=item -f, --script FILE

Take instructions from FILE
when done processing instructions in parameters.
May specify multiple times.

=item -v, --verbose

=back

=cut

use Data::Dumper;
use Getopt::Long qw/:config no_ignore_case bundling pass_through/;
use feature qw/switch/;
use Pod::Usage;
# Term::ReadLine::Gnu is recommended
$readline_support = eval q{ use Term::ReadLine; 1; };
use POSIX;
use Carp qw/croak/;

$0 =~ s/.*\/([^\/]+)$/$1/;
%Opt = (
	'confirm' => 0,
	'verbose' => 0,
);
@OptEditorScript = ();

GetOptions(
	'c|confirm' => \$Opt{'confirm'},
	'v|verbose' => \$Opt{'verbose'},
	'f|script=s@' => \@OptEditorScript,
	'help|?' => sub{ pod2usage(-exitval=>0, -verbose=>99); },
) or exit 2;


# instruction token ending regexp
my $EOIT = qr/([ \r\n]+|$)/;
my $blockio_buffer_size = 4096;



sub verbose
{
	my $msg = shift;
	if($Opt{'verbose'})
	{
		warn "$0: $msg\n";
	}
}

sub get_text_parameter
{
	my $params_ref = shift;
	my $text = undef;
	if($$params_ref =~ s/^([""''])(.*?)(?<!\\)(?1)$EOIT//)
	{
		my $q = $1;
		$text = $2;
		$text =~ s/\\($q)/$1/g;
		# TODO robust escaping
	}
	elsif($$params_ref =~ s/^([^""'']\S*)$EOIT//)
	{
		$text = $1;
	}
	return $text;
}

sub get_pattern_parameter
{
	my $params_ref = shift;
	my $pattern = get_text_parameter($params_ref);
	my $is_regexp = 0;
	if($pattern =~ m{^/(.*)/([a-zA-Z]*)$})
	{
		$pattern = "(?$2)$1";
		$is_regexp = 1;
	}
	return ($pattern, $is_regexp);
}

sub seeker
{
	my $fdata = shift;
	my $offset = shift;
	my $whence = shift;
	seek $fdata->{'handle'}, $offset, $whence or croak "$0: $fdata->{'path'}: seek: $!";
}

sub readblock
{
	my $fdata = shift;
	my $scalar_ref = shift;
	my $blocksize = shift || $blockio_buffer_size;
	my $bytes = read $fdata->{'handle'}, $$scalar_ref, $blocksize;
	croak "$0: $fdata->{'path'}: read: $!" unless defined $bytes;
	return $bytes;
}

sub read_exact
{
	my $fdata = shift;
	my $scalar_ref = shift;
	my $size = shift;
	my $bytes = readblock $fdata, $scalar_ref, $size;
	if($bytes != $size) { croak "$0: $fdata->{'path'}: could not read $size bytes, only $bytes"; }
	return $bytes;
}

sub overwrite_text
{
	my $fdata = shift;
	my $text = shift;
	print {$fdata->{'handle'}} $text or croak "$0: $fdata->{'path'}: write: $!";
}

sub make_room
{
	my $fdata = shift;
	my $room_size = shift;
	
	my $buffer;
	my $original_pos = curpos($fdata);
	seeker $fdata, 0, SEEK_END;
	
	while(1)
	{
		my $curpos = curpos($fdata);
		my $chunk_size = $curpos - $original_pos;
		last if $chunk_size <= 0;
		$chunk_size = $blockio_buffer_size if $chunk_size > $blockio_buffer_size;
		seeker $fdata, -$chunk_size, SEEK_CUR;
		read_exact $fdata, \$buffer, $chunk_size;
		seeker $fdata, $curpos + $room_size - $chunk_size, SEEK_SET;
		print {$fdata->{'handle'}} $buffer or croak "$0: $fdata->{'path'}: write: $!";
		seeker $fdata, $curpos-$chunk_size, SEEK_SET;
	}
	seeker $fdata, $original_pos, SEEK_SET;
	# TODO maintain $fdata->{'mark'} marks
}

sub insert_text
{
	my $fdata = shift;
	my $text = shift;
	make_room $fdata, length $text;
	return overwrite_text $fdata, $text;
}

sub update_file_size
{
	my $fdata = shift;
	my $pos = curpos($fdata);
	if(seek $fdata->{'handle'}, 0, SEEK_END)
	{
		$fdata->{'size'} = curpos($fdata);
		seek $fdata->{'handle'}, $pos, SEEK_SET;
		return $fdata->{'size'};
	}
	return undef;
}

sub curpos
{
	my $fdata = shift;
	return tell $fdata->{'handle'};
}

sub insert_stream
{
	my $fdata = shift;
	my $stream_data = shift;
	update_file_size $stream_data;
	
	my $buffer;
	my $room_allocated = 0;
	if(defined $stream_data->{'size'})
	{
		make_room $fdata, $stream_data->{'size'};
		$room_allocated = 1;
	}
	while(my $bytes = readblock $stream_data, \$buffer)
	{
		if($room_allocated) { overwrite_text $fdata, $buffer; }
		else                { insert_text $fdata, $buffer; }
	}
}

sub shovel_text
{
	my $src = shift;
	my $pos_start = shift;
	my $pos_stop = shift;
	my $length = $pos_stop - $pos_start;
	my $dest_fh = shift;
	my $callback = shift;
	
	my $original_pos = curpos($src);
	seeker $src, $pos_start, SEEK_SET;
	my $buffer;
	while(1)
	{
		last if $length <= 0;
		my $pos = curpos($src);
		my $size = $length < $blockio_buffer_size ? $length : $blockio_buffer_size;
		$length -= readblock $src, \$buffer, $size;
		if($callback)
		{
			$callback->($pos, \$buffer);
		}
		else
		{
			print {$dest_fh} $buffer;
		}
	}
	seeker $src, $original_pos, SEEK_SET;
}

sub delete_chars
{
	my $fdata = shift;
	my $length = shift;
	
	my $buffer;
	my $original_pos = curpos($fdata);
	my $continue_write_pos = $original_pos;
	seeker $fdata, $length, SEEK_CUR;
	while(readblock $fdata, \$buffer)
	{
		seeker $fdata, $continue_write_pos, SEEK_SET;
		print {$fdata->{'handle'}} $buffer or croak "$0: $fdata->{'path'}: write: $!";
		$continue_write_pos = curpos($fdata);
		seeker $fdata, $length, SEEK_CUR;
	}
	truncate $fdata->{'handle'}, $continue_write_pos;
	seeker $fdata, $original_pos, SEEK_SET;
	# TODO maintain $fdata->{'mark'} marks
}

sub search_pattern
{
	my $fdata = shift;
	my $pattern = shift;
	my $is_regexp = shift;
	
	my $original_pos = curpos($fdata);
	my $chunk_start_pos = $original_pos;
	my $found_pos = undef;
	my $matched_string;
	
	while(my $chunk = readline $fdata->{'handle'})
	{
		if($is_regexp)
		{
			if($chunk =~ $pattern)
			{
				$found_pos = $chunk_start_pos + length $`;
				$matched_string = $&;
			}
		}
		else
		{
			my $index = index $chunk, $pattern;
			if($index >= 0)
			{
				$found_pos = $chunk_start_pos + $index;
				$matched_string = $pattern;
			}
		}
		last if defined $found_pos;
		$chunk_start_pos = curpos($fdata);
	}
	
	seeker $fdata, $original_pos, SEEK_SET;
	
	return ($found_pos, $matched_string);
}

sub process_instructions
{
	my $instructions = shift;
	
	while(1)
	{
		my $position_before_operation;
		$position_before_operation = curpos($curfile) if $curfile;
		$instructions =~ s/^\s*//;
=pod

=head1 INSTRUCTIONS

=over 4

=item open [or create] PATH [as NAME]

=item open NAME

Open PATH file to edit.
You can switch between multiple opened files by invoking C<open PATH>
again,
or C<open NAME> if you opened that file under a certain NAME by
C<as NAME>.
You can not open a file on path NAME once you set NAME as an alias for
an other PATH.
But you cat always refer to the same path by prepending C<./> (or C</>
in case of absolute paths) to it.
Don't worry, it won't open the same PATH multiple time with conflicting
editor states.
You have to open a file before any operation.

=cut
		if($instructions =~ s/^open$EOIT//)
		{
			my $may_create = 0;
			if($instructions =~ s/^or create$EOIT//)
			{
				$may_create = 1;
			}
			
			my $key = get_text_parameter \$instructions;
			croak "$0: file path or alias expected to open" unless length $key;
			
			my $alias;
			if($instructions =~ s/^as (\S+)$EOIT//)
			{
				$alias = $1;
			}
			
			my $path;
			if(not defined $alias)
			{
				# "open NAME" form -> check aliases
				if(exists $filepathalias{$key})
				{
					$path = $filepathalias{$key};
				}
			}
			if(not defined $path)
			{
				# either "open NAME" form and NAME alias is not found,
				# or "open PATH" or "open PATH as NAME" form
				$path = $key;
			}
			if(not exists $openedfile{$path})
			{
				# file is not yet open
				my $handle;
				if($may_create)
				{
					use Fcntl;
					sysopen $handle, $path, O_RDWR|O_CREAT or croak "$0: $path: open: $!";
				}
				else
				{
					open $handle, '+<', $path or croak "$0: $path: open: $!";
				}
				$openedfile{$path} = {
					'handle' => $handle,
					'path' => $path,
				};
				$openedfile{$path}->{'mark'}->{'START'} = 0;
				$openedfile{$path}->{'mark'}->{'END'} = update_file_size $openedfile{$path};
			}
			
			$curfile = $openedfile{$path};
			$filepathalias{$alias} = $path if defined $alias;
			verbose sprintf "%s: opened%s", $path, defined $alias ? " as $alias" : "";
			verbose sprintf "cursor at %d size %d", curpos($curfile), $curfile->{'size'};
		}
		elsif($instructions =~ s/^goto$EOIT//)
		{
			my $goto_pos = undef;
			my $whence = SEEK_SET;
=pod

=item goto end of [last] search result

=cut
			if($instructions =~ s/^end of( last)? search result$EOIT//)
			{
				my $c = $last_search_is_regexp ? '/' : '"';
				croak "$0: last search ($c$last_search_pattern$c) was not found" if not defined $last_search_result;
				$goto_pos = $last_search_result_pos + 1 + length $last_search_result;
			}
=pod

=item goto [start | end] [of file]

=item goto [start | end] of line

=cut
			elsif($instructions =~ s/^(?<ANCHOR>start|end)( of (?<SCOPE>file|line))?$EOIT//)
			{
				if($+{'SCOPE'} eq 'line')
				{
					if($+{'ANCHOR'} eq 'end')
					{
						my $rest_of_line = readline $curfile->{'handle'};
						if(substr $rest_of_line, -1 eq "\n")
						{
							seeker $curfile, -1, SEEK_CUR;
						}
					}
					else  # start
					{
						my $buffer;
						my $pos = $position_before_operation;
						while($pos != 0)
						{
							if($pos < $blockio_buffer_size)
							{
								seeker $curfile, 0, SEEK_SET;
								readblock $curfile, \$buffer, $pos;
								$pos = 0;
							}
							else
							{
								seeker $curfile, $blockio_buffer_size, SEEK_CUR;
								$pos = curpos($curfile);
								readblock $curfile, \$buffer;
							}
							my $idx = rindex $buffer, "\n";
							if($idx >= 0)
							{
								$goto_pos = $pos + $idx + 1;
								last;
							}
							seeker $curfile, $pos, SEEK_SET;
						}
					}
				}
				else  # file
				{
					$goto_pos = 0;
					$whence = $+{'ANCHOR'} eq 'start' ? SEEK_SET : SEEK_END;
				}
			}
=pod

=item goto [previous | next] line

=cut
			elsif($instructions =~ s/^(?<DIRECTION>next|previous) line$EOIT//)
			{
				if($+{'DIRECTION'} eq 'next')
				{
					readline $curfile->{'handle'};
				}
				else  # previous
				{
					# TODO
				}
			}
=pod

=item goto [back | forward] COUNT line[s]

=cut
			elsif($instructions =~ s/^(?<DIRECTION>back|forward) (?<COUNT>[1-9]\d*) lines?$EOIT//)
			{
				if($+{'DIRECTION'} eq 'forward')
				{
					readline $curfile->{'handle'} for 1..$+{'COUNT'};
				}
				else  # back
				{
					# TODO
				}
			}
=pod

=item goto [line | char] index NUMBER

Lines and char offsets are indexed by 0.

=cut
			elsif($instructions =~ s/^(?<WHAT>line|char) index (?<INDEX>\d+)$EOIT//)
			{
				if($+{'WHAT'} eq 'line')
				{
					seeker $curfile, 0, SEEK_SET;
					readline $curfile->{'handle'} for 1..$+{'INDEX'};
				}
				else  # goto char index
				{
					seeker $curfile, $+{'INDEX'}, SEEK_SET;
				}
			}
=pod

=item goto mark NAME

Set cursor position in file.

=cut
			elsif($instructions =~ s/^mark (\S+)$EOIT//)
			{
				my $mark = $1;
				croak "$0: $curfile->{'path'}: mark $mark not found" if not exists $curfile->{'mark'}->{$mark};
				$goto_pos = $curfile->{'mark'}->{$mark};
			}
			else
			{
				croak "$0: invalid GOTO: $instructions";
			}
			
			if(defined $goto_pos)
			{
				seeker $curfile, $goto_pos, $whence;
			}
		}
=pod

=item go [up | down | left | right] [COUNT times]

=cut
		elsif($instructions =~ s/^go (?<WHERE>up|down|left|right)( (?<COUNT>[1-9]\d*) times|)$EOIT//)
		{
			my $count = $+{'COUNT'} || 1;
			given($+{'WHERE'})
			{
				when('right') {
					my $tmp;
					read $curfile->{'handle'}, $tmp, $count or croak "$0: $curfile->{'path'}: read: $!";
				}
				when('left') {
					$count = $position_before_operation if $count > $position_before_operation;
					seeker $curfile, -$count, SEEK_CUR if $count;
				}
				when('down') {
					readline $curfile->{'handle'};
					my $x;
					read $curfile->{'handle'}, $x, $count or croak "$0: $curfile->{'path'}: read: $!";
					# FIXME offset in line?
				}
				when('up') {
				}
				# TODO
			}
		}
=pod

=item type STRING

=item enter STRING

Insert given STRING into the current cursor position.
It does not overwrite current selection.
Add newline to the end only if called as c<enter>.

=cut
		elsif($instructions =~ s/^(type|enter)$EOIT//)
		{
			my $end = $1 eq 'enter' ? "\n" : "";
			my $text = get_text_parameter \$instructions;
			croak "$0: text not given to type in" unless defined $text;
			insert_text $curfile, $text.$end;
			verbose sprintf "inserted %d bytes at %d", length $text.$end, $position_before_operation;
		}
=pod

=item overwrite with STRING

=item overtype with STRING

Type given STRING into the current cursor position in overwrite mode.
It does not overwrite current selection, but the text itself
let it be currently selected or not.

=cut
		elsif($instructions =~ s/^over(write|type) with$EOIT//)
		{
			my $text = get_text_parameter \$instructions;
			croak "$0: text not given to overwrite with" unless defined $text;
			overwrite_text $curfile, $text;
			verbose sprintf "written over %d bytes at %d", length $text, $position_before_operation;
		}
=pod

=item replace all [[occurrences of] PATTERN] to STRING

=item replace all [occurrences | PATTERN] to STRING

=item replace [next [COUNT]] [[occurrence[s] of] PATTERN] to STRING

=item replace [next [COUNT]] [occurrence[s] | PATTERN] to STRING

Replace given PATTERN to STRING.
If PATTERN is not given, then the last search pattern will be used.
"Replace next" changes only the next COUNT number of occurrences
starting from the cursor position.
Default is 1 occurrence, if COUNT is not given.
"Replace all" changes all the occurrences from the cursor position down
to the end of file.
If you want to replace all the occurrences in the whole file,
"goto start" first.

=cut
		elsif($instructions =~ s/^replace( (?<LIMIT>all|next( (?<COUNT>[1-9]\d*)|))|)(?<OCCUR> occurrences?(?<OF> of|)|)$EOIT//)
		{
			croak "$0: don't understand this REPLACE instruction" if not $+{'LIMIT'} and $+{'OCCUR'};
			my $replace_count = $+{'LIMIT'} eq 'all' ? undef : ($+{'COUNT'}||1);
			my $expect_pattern;
			$expect_pattern = 1 if $+{'OF'};
			$expect_pattern = 0 if $+{'OCCUR'} and not $+{'OF'};
			my $pattern;
			my $is_regexp = 0;
			my $text;
			
			if((not defined $expect_pattern and $instructions !~ /^to$EOIT/) or $expect_pattern eq 1)
			{
				($pattern, $is_regexp) = get_pattern_parameter \$instructions;
				croak "$0: string/pattern not given what to replace" unless length $pattern;
			}
			else  # not expecting PATTERN to be given here
			{
				$pattern = $last_search_pattern;
				$is_regexp = $last_search_is_regexp;
			}
			
			if($instructions =~ s/^to$EOIT//)
			{
				$text = get_text_parameter \$instructions;
			}
			croak "$0: string not given to replace pattern to" unless defined $text;
			
			my $replacements = 0;
			
			while(not defined $replace_count or $replace_count > 0)
			{
				my ($found_pos, $matched_string) = search_pattern $curfile, $pattern, $is_regexp;
				
				if(defined $found_pos)
				{
					seeker $curfile, $found_pos, SEEK_SET;
					my $found_length = length $matched_string;
					my $length_to_delete = $found_length - length $text;
					if($length_to_delete >= 0)
					{
						delete_chars $curfile, $length_to_delete if $length_to_delete > 0;
						overwrite_text $curfile, $text;
					}
					else
					{
						overwrite_text $curfile, substr($text, 0, $found_length);
						insert_text $curfile, substr($text, $found_length);
					}
					verbose "replaced \"$matched_string\" to \"$text\" at $found_pos";
					$replace_count -= 1 if defined $replace_count;
					$replacements += 1;
				}
				else
				{
					last;
				}
			}
			
			if(not defined $replace_count or $replacements == 0)
			{
				verbose "replaced $replacements occurrences";
			}
		}
=pod

=item delete COUNT char[s]

=cut
		elsif($instructions =~ s/^delete ([1-9]\d*) chars?$EOIT//)
		{
			delete_chars $curfile, $1;
		}
=pod

=item search [next] PATTERN [backward]

Find next occurrence (or previous one if "backward" is specified) of
PATTERN and set the cursor to it.
PATTERN is either a bare word, a string enclosed in quotes, or a regexp
enclosed in slashes (C</regexp/>).
PATTERN is not supported to overhang from one line to the next.
Remove newlines from the text if you must.
If the cursor is at a matching text, C<search PATTERN> will find the
very place where we are, while C<search next ...> skips 1 char and
continues from there.

=item search next [//]

Continue searching the next occurrence of the last search query.
You may close this instruction with an empty pattern (C<//>) to
separate it from the next instruction, since the empty search PATTERN
(both fixed text and regexp) is invalid.

=cut
		elsif($instructions =~ s/^search(?<NEXT> next|)$EOIT//)
		{
			my $next = 1 if $+{'NEXT'};
			my ($pattern, $is_regexp) = get_pattern_parameter(\$instructions);
			if($next and length $pattern == 0)
			{
				$pattern = $last_search_pattern;
				$is_regexp = $last_search_is_regexp;
			}
			croak "$0: string/pattern not given what to search for" unless length $pattern;
			
			my $backward = 0;
			if($instructions =~ s/^backwards?$EOIT//)
			{
				$backward = 1;
			}
			# TODO search backward
			
			DO_SEARCH:
			my ($found_pos, $matched_string) = search_pattern $curfile, $pattern, $is_regexp;
			if($found_pos == $position_before_operation and $next)
			{
				seeker $curfile, +1, SEEK_CUR;
				$next = 0;
				goto DO_SEARCH;
			}
			
			if(defined $found_pos)
			{
				seeker $curfile, $found_pos, SEEK_SET;
				my $len = length $matched_string;
				verbose "match found at $found_pos, length $len";
			}
			else
			{
				verbose "not found";
				seeker $curfile, $position_before_operation, SEEK_SET;
			}
			$last_search_pattern = $pattern;
			$last_search_is_regexp = $is_regexp;
			$last_search_result_pos = $found_pos;
			$last_search_result = $matched_string;
		}
=pod

=item mark as NAME

=cut
		elsif($instructions =~ s/^mark as (\S+)$EOIT//)
		{
			$curfile->{'mark'}->{$1} = $position_before_operation;
		}
=pod

=item select from START-MARK to END-MARK

Select text from the previously named mark START-MARK to END-MARK.
Put marks with C<mark as> command.
You have special marks called C<START> and C<END> which are the very start
and very end of the currently opened file respectively.

=cut
		elsif($instructions =~ s/^select from (\S+) to (\S+)$EOIT//)
		{
			$curfile->{'mark'}->{'SELECTION-START'} = undef;
			$curfile->{'mark'}->{'SELECTION-END'}   = undef;
			# TODO make it fatal error?
			if(not exists $curfile->{'mark'}->{$1}) { verbose "mark $1 not found"; }
			elsif(not exists $curfile->{'mark'}->{$2}) { verbose "mark $2 not found"; }
			else {
				my $pos1 = $curfile->{'mark'}->{$1};
				my $pos2 = $curfile->{'mark'}->{$2};
				$curfile->{'mark'}->{'SELECTION-START'} = $pos1 < $pos2 ? $pos1 : $pos2;
				$curfile->{'mark'}->{'SELECTION-END'}   = $pos1 > $pos2 ? $pos1 : $pos2;
			}
		}
=pod

=item select [last] search result

=item select none

=cut
		elsif($instructions =~ s/^select( none|( last|) search result)$EOIT//)
		{
			my $what = $1;
			$curfile->{'mark'}->{'SELECTION-START'} = undef;
			$curfile->{'mark'}->{'SELECTION-END'}   = undef;
			if($what =~ /search result/)
			{
				croak "$0: no last search result to select" if not defined $last_search_result_pos;
				$curfile->{'mark'}->{'SELECTION-START'} = $last_search_result_pos;
				$curfile->{'mark'}->{'SELECTION-END'}   = $last_search_result_pos + length $last_search_result;
			}
		}
=pod

=item select [COUNT] [char[s] | word[s] | line[s]]

=cut
=pod

=item copy [selection]

=item copy [last] search result

=item cut [selection]

=item cut [last] search result

=item delete [selection]

=item delete [last] search result

=cut
		elsif($instructions =~ s/^(?<CMD>copy|cut|delete)(?<WHAT> selection|( last|) search result|)$EOIT//)
		{
			my $cmd = $+{'CMD'};
			my $what = $+{'WHAT'};
			my $p1;
			my $p2;
			if($what =~ /search result/)
			{
				croak "$0: no last search result to $cmd" if not defined $last_search_result_pos;
				$p1 = $last_search_result_pos;
				$p2 = $p1 + length $last_search_result;
			}
			else  # selection
			{
				$p1 = $curfile->{'mark'}->{'SELECTION-START'};
				$p2 = $curfile->{'mark'}->{'SELECTION-END'};
				croak "$0: $curfile->{'path'}: no selection to $cmd" unless defined $p1 and defined $p2;
			}
			if($cmd ~~ qw/copy cut/)
			{
				seeker $curfile, $p1, SEEK_SET;
				read_exact $curfile, \$Clipboard, $p2-$p1;
				seeker $curfile, $p1, SEEK_SET;
			}
			if($cmd ~~ qw/cut delete/)
			{
				delete_chars $curfile, $p2-$p1;
			}
		}
=pod

=item paste [selection]

=cut
		elsif($instructions =~ s/^paste( selection|)$EOIT//)
		{
			insert_text $curfile, $Clipboard;
			verbose sprintf "pasted %d byes at %d", length $Clipboard, $position_before_operation;
		}
=pod

=item undo

=item redo

=cut
=pod

=item insert file FILE

=item insert output of COMMAND

Insert FILE's contents or the output (stdout) of COMMAND
to the current cursor position.

=item filter selection through COMMAND

=item send selection to COMMAND

Send selected text to COMMAND as stdin,
and in case of C<filter>, replace selection with its stdout.

=cut
		elsif($instructions =~ s/^(?<CMD>insert (?<WHAT>file|output of)|filter selection through|send selection to)$EOIT//)
		{
			my $cmd = $+{'CMD'};
			my $source_type = $+{'WHAT'};
			$cmd =~ s/^(\S+).*/$1/;
			my $source = get_text_parameter \$instructions;
			croak "$0: file/command not given to insert/filter/send to" unless length $source;
			my $stream_data = {};
			
			if($source_type eq 'file')
			{
				open $stream_data->{'handle'}, '<', $source or croak "$0: $source: open: $!";
				$stream_data->{'path'} = $source;
			}
			else  # command
			{
				my $filter_pid;
				my $ext_command_input;
				
				given($cmd)
				{
					when('insert')
					{
						$stream_data->{'path'} = "<($source)";
						open $stream_data->{'handle'}, '-|', $source or croak "$0: open $stream_data->{'path'}: $!";
					}
					when('send')
					{
						$stream_data->{'path'} = "|$source";
						open $ext_command_input, '|-', $source or croak "$0: open $stream_data->{'path'}: $!";
					}
					when('filter')
					{
						$stream_data->{'path'} = "<(|$source)";
						use IPC::Open2;
						$filter_pid = open2($stream_data->{'handle'}, $ext_command_input, $source);
					}
				}
				if(defined $ext_command_input)
				{
					if(defined $curfile->{'mark'}->{'SELECTION-START'} and defined $curfile->{'mark'}->{'SELECTION-END'})
					{
						shovel_text $curfile, $curfile->{'mark'}->{'SELECTION-START'}, $curfile->{'mark'}->{'SELECTION-END'}, $ext_command_input;
					}
					else
					{
						croak "$0: $curfile->{'path'}: there is not any selection to $cmd";
					}
					close $ext_command_input or croak "$0: close pipe: $!";
				}
			}
			
			if(defined $stream_data->{'handle'})
			{
				my $overwrite_length;
				if($cmd eq 'filter')
				{
					seeker $curfile, $curfile->{'mark'}->{'SELECTION-START'}, SEEK_SET;
					$overwrite_length = $curfile->{'mark'}->{'SELECTION-END'} - $curfile->{'mark'}->{'SELECTION-START'};
					my $buf;
					my $size;
					while(1)
					{
						last if $overwrite_length <= 0;
						$size = $overwrite_length < $blockio_buffer_size ? $overwrite_length : $blockio_buffer_size;
						my $nbytes = readblock $stream_data, \$buf, $size;
						$overwrite_length -= $nbytes;
						overwrite_text $curfile, $buf;
						last if $nbytes == 0;
					}
				}
				insert_stream $curfile, $stream_data;
				close $stream_data->{'handle'};
				if($cmd eq 'filter' and $overwrite_length > 0)
				{
					delete_chars $curfile, $overwrite_length;
				}
			}
		}
=pod

=item uppercase

=item lowercase

=item capitalize

=cut
		elsif($instructions =~ s/^(uppercase|lowercase|capitalize)$EOIT//)
		{
			my $op = $1;
			if(defined $curfile->{'mark'}->{'SELECTION-START'} and defined $curfile->{'mark'}->{'SELECTION-END'})
			{
				seeker $curfile, $selection_start, SEEK_SET;
				# TODO
			}
			else
			{
				verbose "there is not any selection";
			}
		}
=pod

=item show open[ed] file[s]

Display a list of file paths which were opened.
The one in foreground prefixed with an C<*> asterisk.
If any of them opened by an alias name, it shown after the path in C<[]> brackets.

=cut
		elsif($instructions =~ s/^show open(ed)? files?$EOIT//)
		{
			for my $path (keys %openedfile)
			{
				printf "%s %s", ($path eq $curfile->{'path'}) ? '*' : ' ', $path;
				for my $alias (keys %filepathalias)
				{
					print "\t[$alias]" if $filepathalias{$alias} eq $path;
				}
				print "\n";
			}
		}
=pod

=item show contents [with cursor] [with selection] [with marks]

Show the contents of the file in foreground.

=cut
		elsif($instructions =~ s/^show contents(?<WITH>( with (cursor|selection|marks))*)$EOIT//)
		{
			my $extras = $+{'WITH'};
			update_file_size $curfile;
			shovel_text $curfile, 0, $curfile->{'size'}, undef, sub
				{
					my $pos = shift;
					my $data_ref = shift;
					my $end = $pos + length $$data_ref;
					my @inserts;
					if($extras =~ /selection/)
					{
						my $p1 = $curfile->{'mark'}->{'SELECTION-START'};
						if(defined $p1 and $pos <= $p1 and $p1 < $end)
						{
							# put "selection start" signal in the stream
							push @inserts, {'where' => $p1-$pos, 'what' => "\x1B[7m"};
						}
						my $p2 = $curfile->{'mark'}->{'SELECTION-END'};
						if(defined $p2 and $pos <= $p2 and $p2 < $end)
						{
							# put "selection end" signal in the stream
							push @inserts, {'where' => $p2-$pos, 'what' => "\x1B[27m"};
						}
					}
					if($extras =~ /cursor/)
					{
						if($pos <= $position_before_operation and $position_before_operation < $end)
						{
							push @inserts, {'where' => $position_before_operation-$pos,   'what' => "\x1B[4m"};
							push @inserts, {'where' => $position_before_operation-$pos+1, 'what' => "\x1B[24m"};
						}
					}
					if($extras =~ /marks/)
					{
						for my $mark (keys $curfile->{'mark'})
						{
							next if $mark =~ /^(SELECTION-|)(START|END)$/;
							my $p = $curfile->{'mark'}->{$mark};
							if($pos <= $p and $p < $end)
							{
								push @inserts, {'where' => $p-$pos, 'what' => "\x1B[1m[$mark]\x1B[22m"};
							}
						}
					}
					@inserts = sort {$a->{'where'} <=> $b->{'where'}} @inserts;
					my $prev_slice_end = 0;
					for my $ins (@inserts)
					{
						print substr($$data_ref, $prev_slice_end, $ins->{'where'} - $prev_slice_end);
						print $ins->{'what'};
						$prev_slice_end = $ins->{'where'};
					}
					print substr($$data_ref, $prev_slice_end);
				};
			
			seeker $curfile, $position_before_operation, SEEK_SET;
		}
=pod

=item show cursor

=cut
		elsif($instructions =~ s/^show cursor$EOIT//)
		{
			print $position_before_operation;
			print "\n";
		}
=pod

=item show marks

=cut
		elsif($instructions =~ s/^show marks$EOIT//)
		{
			for my $mark (sort {$curfile->{'mark'}->{$a} <=> $curfile->{'mark'}->{$b}} keys $curfile->{'mark'})
			{
				printf "%d\t%s\n", $curfile->{'mark'}->{$mark}, $mark;
			}
		}
=pod

=item set OPTION [on | off]

=item unset OPTION

I<OPTION>s: verbose

=cut
		elsif($instructions =~ s/^((?<CMD>set) (?<OPT>\S+)( (?<STATE>on|off)|)|(?<CMD>unset) (?<OPT>\S+))$EOIT//)
		{
			my $state = ($+{'CMD'} eq 'unset' or $+{'STATE'} eq 'off') ? 0 : 1;
			croak "$0: unknown option $+{'OPT'}" unless exists $Opt{$+{'OPT'}};
			$Opt{$+{'OPT'}} = $state;
		}
=pod

=item [show] help

=cut
		elsif($instructions =~ s/^(show |)help$EOIT//)
		{
			pod2usage(-exitval=>'NOEXIT', -verbose=>99);
		}
		elsif($instructions eq '')
		{
			last;
		}
		else
		{
			croak "$0: invalid instruction: $instructions";
		}
	}
=pod

=back

=cut
}



# TODO optional backup files

my %openedfile = ();
my %filepathalias = ();
my $curfile;
my $instructions_found = 1;

my $last_search_pattern = undef;
my $last_search_is_regexp = undef;
my $last_search_result = undef;
my $Clipboard = '';


if(@ARGV)
{
	my $Instructions = join ' ', map { if(/[ \r\n""]/ or $_ eq ''){ s/[""]/\\$&/g; $_="\"$_\""; }; $_ } @ARGV;
	process_instructions $Instructions;
}

for my $espath (@OptEditorScript)
{
	open my $es, '<', $espath or croak "$0: $espath: open: $!";
	local $/ = undef;
	my $Instructions = <$es>;
	process_instructions $Instructions;
	close $es;
}

# TODO readline
while(my $Instructions = <STDIN>)
{
	eval { process_instructions $Instructions; 1; };
	warn $@ if $@;
}


my $close_err = 0;
for my $curfile (values %openedfile)
{
	close $curfile->{'handle'} and next;
	$close_err = $!;
	warn "$0: $curfile->{'path'}: close: $!\n";
}
exit $close_err;


# TODO positioning and offsets should represent chars, not bytes (multibyte support)
