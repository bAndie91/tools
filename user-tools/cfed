#!/usr/bin/env perl

=pod

=head1 NAME

cfed - Command File-Editor - Edit text files by commands directly from shell

=head1 SYNOPSIS

 cfed [<OPTIONS>] <INSTRUCTIONS>

=head1 DESCRIPTION

Edit files by giving editor commands like shell commands.
Sematics are similar to well known text editors:
open file, move cursor, search and replace, select, copy, paste, ...

May open multiple files.
Always one file is in the foreground.
All opened files has a cursor position at which most commands are
applied.
When a file is opened its cursor set to the start position.

Files also have several marks which you can set or refer to in
C<select> or C<goto> commands.

You have one clipboard.

=head1 OPTIONS

=over 4

=item -f, --script FILE

Take instructions from FILE, not from parameters.

=item -v, --verbose

=back

=cut

use Data::Dumper;
use Getopt::Long qw/:config no_ignore_case bundling pass_through/;
use feature qw/switch/;
use Pod::Usage;
# Term::ReadLine::Gnu is recommended
$readline_support = eval q{ use Term::ReadLine; 1; };
use POSIX;
use Carp qw/croak/;

$0 =~ s/.*\/([^\/]+)$/$1/;
$OptConfirm = 0;
$OptVerbose = 0;
$OptEditorScript = undef;

GetOptions(
	'c|confirm' => \$OptConfirm,
	'v|verbose' => \$OptVerbose,
	'f|script=s'  => \$OptEditorScript,
	'help|?' => sub{ pod2usage(-exitval=>0, -verbose=>99); },
) or exit 2;


# instruction token ending regexp
my $EOIT = qr/([ \r\n]+|$)/;
my $blockio_buffer_size = 4096;



sub verbose
{
	my $msg = shift;
	if($OptVerbose)
	{
		warn "$0: $msg\n";
	}
}

sub get_text_parameter
{
	my $params_ref = shift;
	my $text = undef;
	if($$params_ref =~ s/^([""''])(.*?)(?<!\\)(?1)$EOIT//)
	{
		my $q = $1;
		$text = $2;
		$text =~ s/\\($q)/$1/g;
		# TODO robust escaping
	}
	elsif($$params_ref =~ s/^([^""'']\S*)$EOIT//)
	{
		$text = $1;
	}
	return $text;
}

sub get_pattern_parameter
{
	my $params_ref = shift;
	my $pattern = get_text_parameter($params_ref);
	my $is_regexp = 0;
	if($pattern =~ m{^/(.*)/([a-zA-Z]*)$})
	{
		$pattern = "(?$2)$1";
		$is_regexp = 1;
	}
	return ($pattern, $is_regexp);
}

sub seeker
{
	my $fdata = shift;
	my $offset = shift;
	my $whence = shift;
	seek $fdata->{'handle'}, $offset, $whence or croak "$0: $fdata->{'path'}: seek: $!";
}

sub readblock
{
	my $fdata = shift;
	my $scalar_ref = shift;
	my $blocksize = shift || $blockio_buffer_size;
	my $bytes = read $fdata->{'handle'}, $$scalar_ref, $blocksize;
	croak "$0: $fdata->{'path'}: read: $!" unless defined $bytes;
	return $bytes;
}

sub overwrite_text
{
	my $fdata = shift;
	my $text = shift;
	print {$fdata->{'handle'}} $text or croak "$0: $fdata->{'path'}: write: $!";
}

sub make_room
{
	my $fdata = shift;
	my $room_size = shift;
	
	my $buffer;
	my $original_pos = tell $fdata->{'handle'};
	seeker $fdata, 0, SEEK_END;
	
	while(1)
	{
		my $curpos = tell $fdata->{'handle'};
		my $chunk_size = $curpos - $original_pos;
		last if $chunk_size <= 0;
		$chunk_size = $blockio_buffer_size if $chunk_size > $blockio_buffer_size;
		seeker $fdata, -$chunk_size, SEEK_CUR;
		my $bytes = readblock $fdata, \$buffer, $chunk_size;
		croak sprintf "%s: %s: can not read %d bytes at %d", $0, $fdata->{'path'}, $chunk_size, $curpos-$chunk_size if $bytes != $chunk_size;
		seeker $fdata, $curpos + $room_size - $chunk_size, SEEK_SET;
		print {$fdata->{'handle'}} $buffer or croak "$0: $fdata->{'path'}: write: $!";
		seeker $fdata, $curpos-$chunk_size, SEEK_SET;
	}
	seeker $fdata, $original_pos, SEEK_SET;
	# TODO maintain $fdata->{'mark'} marks
}

sub insert_text
{
	my $fdata = shift;
	my $text = shift;
	make_room $fdata, length $text;
	return overwrite_text $fdata, $text;
}

sub find_size
{
	my $fdata = shift;
	my $pos = tell $fdata->{'handle'};
	if(seek $fdata->{'handle'}, 0, SEEK_END)
	{
		$fdata->{'size'} = tell $fdata->{'handle'};
		seek $fdata->{'handle'}, $pos, SEEK_SET;
	}
}

sub insert_stream
{
	my $fdata = shift;
	my $stream_data = shift;
	find_size $stream_data;
	
	my $buffer;
	my $room_allocated = 0;
	if(defined $stream_data->{'size'})
	{
		make_room $fdata, $stream_data->{'size'};
		$room_allocated = 1;
	}
	while(my $bytes = readblock $stream_data, \$buffer)
	{
		if($room_allocated) { overwrite_text $fdata, $buffer; }
		else                { insert_text $fdata, $buffer; }
	}
}

sub shovel_text
{
	my $src = shift;
	my $pos_start = shift;
	my $pos_stop = shift;
	my $length = $pos_stop - $pos_start;
	my $dest_fh = shift;
	
	my $original_pos = tell $src->{'handle'};
	seeker $src, $pos_start, SEEK_SET;
	my $buffer;
	while(1)
	{
		last if $length <= 0;
		my $size = $length < $blockio_buffer_size ? $length : $blockio_buffer_size;
		$length -= readblock $src, \$buffer, $size;
		print {$dest_fh} $buffer;
	}
	seeker $src, $original_pos, SEEK_SET;
}

sub delete_chars
{
	my $fdata = shift;
	my $length = shift;
	
	my $buffer;
	my $original_pos = tell $fdata->{'handle'};
	my $continue_write_pos = $original_pos;
	seeker $fdata, $length, SEEK_CUR;
	while(readblock $fdata, \$buffer)
	{
		seeker $fdata, $continue_write_pos, SEEK_SET;
		print {$fdata->{'handle'}} $buffer or croak "$0: $fdata->{'path'}: write: $!";
		$continue_write_pos = tell $fdata->{'handle'};
		seeker $fdata, $length, SEEK_CUR;
	}
	truncate $fdata->{'handle'}, $continue_write_pos;
	seeker $fdata, $original_pos, SEEK_SET;
	# TODO maintain $fdata->{'mark'} marks
}

sub search_pattern
{
	my $fdata = shift;
	my $pattern = shift;
	my $is_regexp = shift;
	
	my $original_pos = tell $fdata->{'handle'};
	my $chunk_start_pos = $original_pos;
	my $found_pos = undef;
	my $matched_string;
	
	while(my $chunk = readline $fdata->{'handle'})
	{
		if($is_regexp)
		{
			if($chunk =~ $pattern)
			{
				$found_pos = $chunk_start_pos + length $`;
				$matched_string = $&;
			}
		}
		else
		{
			my $index = index $chunk, $pattern;
			if($index >= 0)
			{
				$found_pos = $chunk_start_pos + $index;
				$matched_string = $pattern;
			}
		}
		last if defined $found_pos;
		$chunk_start_pos = tell $fdata->{'handle'};
	}
	
	seeker $fdata, $original_pos, SEEK_SET;
	
	return ($found_pos, $matched_string);
}

sub process_instructions
{
	my $instructions = shift;
	
	my %openedfile = ();
	my %filepathalias = ();
	my $curfile;
	
	my $last_search_pattern = undef;
	my $last_search_is_regexp = undef;
	my $last_search_result = undef;
	my $clipboard = '';
	
	while(1)
	{
		my $position_before_operation;
		$position_before_operation = tell $curfile->{'handle'} if $curfile;
		$instructions =~ s/^\s*//;
=pod

=head1 INSTRUCTIONS

=over 4

=item open [or create] PATH [as NAME]

=item open NAME

Open PATH file to edit.
You can switch between multiple opened files by invoking C<open PATH>
again,
or C<open NAME> if you opened that file under a certain NAME by
C<as NAME>.
You can not open a file on path NAME once you set NAME as an alias for
an other PATH.
But you cat always refer to the same path by prepending C<./> (or C</>
in case of absolute paths) to it.
Don't worry, it won't open the same PATH multiple time with conflicting
editor states.
You have to open a file before any other operation.

=cut
		if($instructions =~ s/^open$EOIT//)
		{
			my $may_create = 0;
			if($instructions =~ s/^or create$EOIT//)
			{
				$may_create = 1;
			}
			
			my $key = get_text_parameter \$instructions;
			croak "$0: file path or alias expected to open" unless length $key;
			
			my $alias;
			if($instructions =~ s/^as (\S+)$EOIT//)
			{
				$alias = $1;
			}
			
			my $path;
			if(not defined $alias)
			{
				# "open NAME" form -> check aliases
				if(exists $filepathalias{$key})
				{
					$path = $filepathalias{$key};
				}
			}
			if(not defined $path)
			{
				# either "open NAME" form and NAME alias is not found,
				# or "open PATH" or "open PATH as NAME" form
				$path = $key;
			}
			if(not exists $openedfile{$path})
			{
				# file is not yet open
				my $handle;
				if($may_create)
				{
					use Fcntl;
					sysopen $handle, $path, O_RDWR|O_CREAT or croak "$0: $path: open: $!";
				}
				else
				{
					open $handle, '+<', $path or croak "$0: $path: open: $!";
				}
				$openedfile{$path} = {'handle' => $handle, 'path' => $path};
				verbose sprintf "%s: opened%s", $path, defined $alias ? " as $alias" : "";
			}
			
			$curfile = $openedfile{$path};
			$filepathalias{$alias} = $path if defined $alias;
			# seek to the start and set START and END marks
			seeker $curfile, 0, SEEK_SET;
			$curfile->{'mark'}->{'START'} = 0;
			find_size $curfile;
			$curfile->{'mark'}->{'END'} = $curfile->{'size'};
		}
		elsif($instructions =~ s/^goto$EOIT//)
		{
			my $goto_pos = undef;
			my $whence = SEEK_SET;
=pod

=item goto end of [last] search result

=cut
			if($instructions =~ s/^end of( last)? search result$EOIT//)
			{
				my $c = $last_search_is_regexp ? '/' : '"';
				croak "$0: last search ($c$last_search_pattern$c) was not found" if not defined $last_search_result;
				$goto_pos = $last_search_result_pos + 1 + length $last_search_result;
			}
=pod

=item goto [start | end] [of file]

=item goto [start | end] of line

=cut
			elsif($instructions =~ s/^(?<ANCHOR>start|end)( of (?<SCOPE>file|line))?$EOIT//)
			{
				if($+{'SCOPE'} eq 'line')
				{
					if($+{'ANCHOR'} eq 'end')
					{
						my $rest_of_line = readline $curfile->{'handle'};
						if(substr $rest_of_line, -1 eq "\n")
						{
							seeker $curfile, -1, SEEK_CUR;
						}
					}
					else  # start
					{
						my $buffer;
						my $pos = $position_before_operation;
						while($pos != 0)
						{
							if($pos < $blockio_buffer_size)
							{
								seeker $curfile, 0, SEEK_SET;
								readblock $curfile, \$buffer, $pos;
								$pos = 0;
							}
							else
							{
								seeker $curfile, $blockio_buffer_size, SEEK_CUR;
								$pos = tell $curfile->{'handle'};
								readblock $curfile, \$buffer;
							}
							my $idx = rindex $buffer, "\n";
							if($idx >= 0)
							{
								$goto_pos = $pos + $idx + 1;
								last;
							}
							seeker $curfile, $pos, SEEK_SET;
						}
					}
				}
				else  # file
				{
					$goto_pos = 0;
					$whence = $+{'ANCHOR'} eq 'start' ? SEEK_SET : SEEK_END;
				}
			}
=pod

=item goto [previous | next] line

=cut
			elsif($instructions =~ s/^(?<DIRECTION>next|previous) line$EOIT//)
			{
				if($+{'DIRECTION'} eq 'next')
				{
					readline $curfile->{'handle'};
				}
				else  # previous
				{
					# TODO
				}
			}
=pod

=item goto [back | forward] COUNT line[s]

=cut
			elsif($instructions =~ s/^(?<DIRECTION>back|forward) (?<COUNT>[1-9]\d*) lines?$EOIT//)
			{
				if($+{'DIRECTION'} eq 'forward')
				{
					readline $curfile->{'handle'} for 1..$+{'COUNT'};
				}
				else  # back
				{
					# TODO
				}
			}
=pod

=item goto [line | char] index NUMBER

Lines and char offsets are indexed by 0.

=cut
			elsif($instructions =~ s/^(?<WHAT>line|char) index (?<COUNT>\d*)$EOIT//)
			{
				seeker $curfile, 0, SEEK_SET;
				readline $curfile->{'handle'} for 1..$+{'COUNT'};
				# TODO: char index ...
			}
=pod

=item goto mark NAME

Set cursor position in file.

=cut
			elsif($instructions =~ s/^mark (\S+)$EOIT//)
			{
				my $mark = $1;
				croak "$0: $curfile->{'path'}: mark $mark not found" if not exists $curfile->{'mark'}->{$mark};
				$goto_pos = $curfile->{'mark'}->{$mark};
			}
			else
			{
				croak "$0: invalid GOTO: $instructions";
			}
			
			if(defined $goto_pos)
			{
				seeker $curfile, $goto_pos, $whence;
			}
		}
=pod

=item go [up | down | left | right] [COUNT times]

=cut
		elsif($instructions =~ s/^go (?<WHERE>up|down|left|right)( (?<COUNT>[1-9]\d*) times|)$EOIT//)
		{
			my $count = $+{'COUNT'} || 1;
			given($+{'WHERE'})
			{
				when('right') {
					my $tmp;
					read $curfile->{'handle'}, $tmp, $count or croak "$0: $curfile->{'path'}: read: $!";
				}
				when('left') {
					$count = $position_before_operation if $count > $position_before_operation;
					seeker $curfile, -$count, SEEK_CUR if $count;
				}
				when('down') {
					readline $curfile->{'handle'};
					my $x;
					read $curfile->{'handle'}, $x, $count or croak "$0: $curfile->{'path'}: read: $!";
					# FIXME offset in line?
				}
				when('up') {
				}
				# TODO
			}
		}
=pod

=item type STRING

=item enter STRING

Insert given STRING into the current cursor position.
Add newline to the end only if called as c<enter>.

=cut
		elsif($instructions =~ s/^(type|enter)$EOIT//)
		{
			my $end = $1 eq 'enter' ? "\n" : "";
			my $text = get_text_parameter \$instructions;
			croak "$0: text not given to type in" unless defined $text;
			insert_text $curfile, $text.$end;
			verbose sprintf "%s: inserted %d bytes at %d", $curfile->{'path'}, length $text, $position_before_operation;
		}
=pod

=item overwrite with STRING

=item overtype with STRING

Type given STRING into the current cursor position in overwrite mode.

=cut
		elsif($instructions =~ s/^over(write|type) with$EOIT//)
		{
			my $text = get_text_parameter \$instructions;
			croak "$0: text not given to overwrite with" unless defined $text;
			overwrite_text $curfile, $text;
			verbose sprintf "%s: written over %d bytes at %d", $curfile->{'path'}, length $text, $position_before_operation;
		}
=pod

=item replace all [[occurrences of] PATTERN] to STRING

=item replace all [occurrences | PATTERN] to STRING

=item replace [next [COUNT]] [[occurrence[s] of] PATTERN] to STRING

=item replace [next [COUNT]] [occurrence[s] | PATTERN] to STRING

Replace given PATTERN to STRING.
If PATTERN is not given, then the last search pattern will be used.
"Replace next" changes only the next COUNT number of occurrences
starting from the cursor position.
Default is 1 occurrence, if COUNT is not given.
"Replace all" changes all the occurrences from the cursor position down
to the end of file.
If you want to replace all the occurrences in the whole file,
"goto start" first.

=cut
		elsif($instructions =~ s/^replace( (?<LIMIT>all|next( (?<COUNT>[1-9]\d*)|))|)(?<OCCUR> occurrences?(?<OF> of|)|)$EOIT//)
		{
			croak "$0: don't understand this REPLACE instruction" if not $+{'LIMIT'} and $+{'OCCUR'};
			my $replace_count = $+{'LIMIT'} eq 'all' ? undef : ($+{'COUNT'}||1);
			my $expect_pattern;
			$expect_pattern = 1 if $+{'OF'};
			$expect_pattern = 0 if $+{'OCCUR'} and not $+{'OF'};
			my $pattern;
			my $is_regexp = 0;
			my $text;
			
			if((not defined $expect_pattern and $instructions !~ /^to$EOIT/) or $expect_pattern eq 1)
			{
				($pattern, $is_regexp) = get_pattern_parameter \$instructions;
				croak "$0: string/pattern not given what to replace" unless length $pattern;
			}
			else  # not expecting PATTERN to be given here
			{
				$pattern = $last_search_pattern;
				$is_regexp = $last_search_is_regexp;
			}
			
			if($instructions =~ s/^to$EOIT//)
			{
				$text = get_text_parameter \$instructions;
			}
			croak "$0: string not given to replace pattern to" unless defined $text;
			
			my $replacements = 0;
			
			while(not defined $replace_count or $replace_count > 0)
			{
				my ($found_pos, $matched_string) = search_pattern $curfile, $pattern, $is_regexp;
				
				if(defined $found_pos)
				{
					seeker $curfile, $found_pos, SEEK_SET;
					my $found_length = length $matched_string;
					my $length_to_delete = $found_length - length $text;
					if($length_to_delete >= 0)
					{
						delete_chars $curfile, $length_to_delete if $length_to_delete > 0;
						overwrite_text $curfile, $text;
					}
					else
					{
						overwrite_text $curfile, substr($text, 0, $found_length);
						insert_text $curfile, substr($text, $found_length);
					}
					verbose "$curfile->{'path'}: replaced \"$matched_string\" to \"$text\" at $found_pos";
					$replace_count -= 1 if defined $replace_count;
					$replacements += 1;
				}
				else
				{
					last;
				}
			}
			
			verbose "$curfile->{'path'}: replaced $replacements occurrences";
		}
=pod

=item search PATTERN [backward]

Find next occurrence (or previous one if "backward" is specified) of
PATTERN and set the cursor to it.
PATTERN is either a bare word, a string enclosed in quotes, or a regexp
enclosed in slashes (C</regexp/>).
PATTERN is not supported to overhang from one line to the next.
Remove newlines from the text if you must.

=cut
		elsif($instructions =~ s/^search$EOIT//)
		{
			my ($pattern, $is_regexp) = get_pattern_parameter(\$instructions);
			croak "$0: string/pattern not given what to search for" unless length $pattern;
			
			# TODO search backward
			my ($found_pos, $matched_string) = search_pattern $curfile, $pattern, $is_regexp;
			
			if(defined $found_pos)
			{
				seeker $curfile, $found_pos, SEEK_SET;
			}
			$last_search_pattern = $pattern;
			$last_search_is_regexp = $is_regexp;
			$last_search_result_pos = $found_pos;
			$last_search_result = $matched_string;
		}
=pod

=item mark as NAME

=cut
		elsif($instructions =~ s/^mark as (\S+)$EOIT//)
		{
			$curfile->{'mark'}->{$1} = $position_before_operation;
		}
=pod

=item select from START-MARK to END-MARK

=cut
		elsif($instructions =~ s/^select from (\S+) to (\S+)$EOIT//)
		{
			$curfile->{'mark'}->{'SELECTION-START'} = undef;
			$curfile->{'mark'}->{'SELECTION-STOP'}  = undef;
			if(not exists $curfile->{'mark'}->{$1}) { verbose "$curfile->{'path'}: mark $1 not found"; }
			elsif(not exists $curfile->{'mark'}->{$2}) { verbose "$curfile->{'path'}: mark $2 not found"; }
			else {
				my $pos1 = $curfile->{'mark'}->{$1};
				my $pos2 = $curfile->{'mark'}->{$2};
				$curfile->{'mark'}->{'SELECTION-START'} = $pos1 < $pos2 ? $pos1 : $pos2;
				$curfile->{'mark'}->{'SELECTION-STOP'}  = $pos1 > $pos2 ? $pos1 : $pos2;
			}
		}
=pod

=item select [COUNT] [char[s] | word[s] | line[s]]

=item copy

=item cut

=item paste

=cut
=pod

=item insert file FILE

=item insert output of COMMAND

Insert FILE's contents or the output (stdout) of COIMMAND
to the current cursor position.

=item filter selection through COMMAND

=item send selection to COMMAND

Send selected text to COMMAND as stdin,
and in case of C<filter>, replace selection with its stdout.

=cut
		elsif($instructions =~ s/^(?<CMD>insert (?<WHAT>file|output of)|filter selection through|send selection to)$EOIT//)
		{
			my $cmd = $+{'CMD'};
			my $source_type = $+{'WHAT'};
			$cmd =~ s/^(\S+).*/$1/;
			my $source = get_text_parameter \$instructions;
			croak "$0: file/command not given to insert/filter/send to" unless length $source;
			my $stream_data = {};
			
			if($source_type eq 'file')
			{
				open $stream_data->{'handle'}, '<', $source or croak "$0: $source: open: $!";
				$stream_data->{'path'} = $source;
			}
			else  # command
			{
				my $filter_pid;
				my $ext_command_input;
				
				given($cmd)
				{
					when('insert')
					{
						$stream_data->{'path'} = "<($source)";
						open $stream_data->{'handle'}, '-|', $source or croak "$0: open $stream_data->{'path'}: $!";
					}
					when('send')
					{
						$stream_data->{'path'} = "|$source";
						open $ext_command_input, '|-', $source or croak "$0: open $stream_data->{'path'}: $!";
					}
					when('filter')
					{
						$stream_data->{'path'} = "<(|$source)";
						use IPC::Open2;
						$filter_pid = open2($stream_data->{'handle'}, $ext_command_input, $source);
					}
				}
				if(defined $ext_command_input)
				{
					if(defined $curfile->{'mark'}->{'SELECTION-START'} and defined $curfile->{'mark'}->{'SELECTION-STOP'})
					{
						shovel_text $curfile, $curfile->{'mark'}->{'SELECTION-START'}, $curfile->{'mark'}->{'SELECTION-STOP'}, $ext_command_input;
					}
					else
					{
						croak "$0: $curfile->{'path'}: there is not any selection to $cmd";
					}
					close $ext_command_input or croak "$0: close pipe: $!";
				}
			}
			
			if(defined $stream_data->{'handle'})
			{
				my $overwrite_length;
				if($cmd eq 'filter')
				{
					seeker $curfile, $curfile->{'mark'}->{'SELECTION-START'}, SEEK_SET;
					$overwrite_length = $curfile->{'mark'}->{'SELECTION-STOP'} - $curfile->{'mark'}->{'SELECTION-START'};
					my $buf;
					my $size;
					while(1)
					{
						last if $overwrite_length <= 0;
						$size = $overwrite_length < $blockio_buffer_size ? $overwrite_length : $blockio_buffer_size;
						my $nbytes = readblock $stream_data, \$buf, $size;
						$overwrite_length -= $nbytes;
						overwrite_text $curfile, $buf;
						last if $nbytes == 0;
					}
				}
				insert_stream $curfile, $stream_data;
				close $stream_data->{'handle'};
				if($cmd eq 'filter' and $overwrite_length > 0)
				{
					delete_chars $curfile, $overwrite_length;
				}
			}
		}
=pod

=item uppercase

=item lowercase

=item capitalize

=cut
		elsif($instructions =~ s/^(uppercase|lowercase|capitalize)$EOIT//)
		{
			my $op = $1;
			if(defined $curfile->{'mark'}->{'SELECTION-START'} and defined $curfile->{'mark'}->{'SELECTION-STOP'})
			{
				seeker $curfile, $selection_start, SEEK_SET;
				# TODO
			}
			else
			{
				verbose "$curfile->{'path'}: there is not any selection";
			}
		}
		elsif($instructions eq '')
		{
			last;
		}
		else
		{
			croak "$0: invalid instruction: $instructions";
		}
	}

=pod

=back

=cut
	
	my $close_err = 0;
	for my $curfile (values %openedfile)
	{
		close $curfile->{'handle'} and next;
		$close_err = $!;
		warn "$0: $curfile->{'path'}: close: $!\n";
	}
	return $close_err;
}


if(defined $OptEditorScript)
{
	open my $es, '<', $OptEditorScript or croak "$0: $OptEditorScript: open: $!";
	local $/ = undef;
	$Instructions = <$es>;
}
else
{
	$Instructions = join ' ', map { if(/[ \r\n""]/ or $_ eq ''){ s/[""]/\\$&/g; $_="\"$_\""; }; $_ } @ARGV;
}
croak "$0: not any editing instruction given" unless $Instructions;
#warn Dumper $Instructions;


# TODO optional backup files

exit process_instructions $Instructions;
