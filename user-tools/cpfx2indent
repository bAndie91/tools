#!/usr/bin/env perl

=pod

=head1 NAME

cpfx2indent - Filter text of lines by replacing common prefixes to indentation

=head1 SYNOPSIS

cpfx2indent [I<OPTIONS>]

=head1 DESCRIPTION

Analyzes input lines on STDIN to detect common prefixes
and replaces each lineâ€™s leading segment
with a number of B<TAB>s proportional to the length of the prefix it shares with other lines.

=head1 OPTIONS

=over 4

=item -d, --delimiter I<PATTERN>

Tokenize input lines by I<PATTERN> regexp pattern.
Default is any whitespace (C<\s+>).

=item -i, --indent-by I<STRING>

Indent output by I<STRING>.
Default is B<TAB>.
Other useful I<STRING> are for example space, and double space.

=back

=head1 ENVIRONMENT

=head1 LIMITATIONS

=head1 SEE ALSO

indent2graph(1), indent2tree(1), paths2indent(1)

=cut


use Data::Dumper;
use utf8;
use open ':std', ':utf8';  # mark stdio as utf8 but not verify
use open ':utf8';
use Getopt::Long qw/:config no_ignore_case no_bundling no_getopt_compat no_auto_abbrev pass_through permute/;
use List::MoreUtils qw/all any none/;
use Pod::Usage;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';


sub empty { length($_[0]) == 0 }

$OptDelimiter = '\s+';
$OptIndentBy = "\t";

GetOptions(
	'd|delimiter=s' => \$OptDelimiter,
	'i|indent-by=s' => \$OptIndentBy,
	'help' => sub { pod2usage(-exitval=>0, -verbose=>99); },
	'<>' => sub { unshift @ARGV, $_[0]; die '!FINISH'; },
) or pod2usage(-exitval=>2, -verbose=>99);


$Graph = {};

while(<STDIN>)
{
	my $subgraph = $Graph;
	
	chomp;
	my @tokens = split /($OptDelimiter)/;
	
	while(1)
	{
		my $token = shift @tokens;
		last unless defined $token;
		my $delim_after = shift @tokens;
		if(not exists $subgraph->{$token})
		{
			$subgraph->{$token} = {
				label => $token,
				subgraph => {},
				nth_child => (scalar keys %$subgraph),
				parent => $subgraph,
			};
		}
		if(empty $subgraph->{$token}->{delim_after})
		{
			$subgraph->{$token}->{delim_after} = $delim_after;
		}
		$subgraph = $subgraph->{$token}->{subgraph};
	}
	
	$subgraph->{''} = {
		label => '',
		nth_child => (scalar keys %$subgraph),
		parent => $subgraph,
	};
}

#print Dumper $Graph;

sub subnodes
{
	my $graph = shift;
	return scalar keys %$graph;
}

sub output_subgraph;
sub output_subgraph
{
	my $indent_level = shift;
	my $graph = shift;
	
	for my $node (sort {$a->{nth_child} <=> $b->{nth_child}} values %$graph)
	{
		my $subgraph = $node->{subgraph};
		printf "%s%s\n", $OptIndentBy x $indent_level, $node->{label};
		output_subgraph $indent_level+1, $subgraph;
	}
}

sub reduce_graph
{
	my $node = shift;
	REDUCE_CHECK_SUBNODES:
	my @subkeys = keys %{$node->{subgraph}};
	if(scalar @subkeys == 1)
	{
		my $subnode = $node->{subgraph}->{$subkeys[0]};
		$node->{subgraph} = $subnode->{subgraph};
		
		my $new_label = $node->{label} . $node->{delim_after} . $subnode->{label};
		# TODO check {$new_label}
		if($new_label ne $node->{label})
		{
			$node->{parent}->{$new_label} = $node;
			delete $node->{parent}->{ $node->{label} };
			$node->{label} = $new_label;
		}
		goto REDUCE_CHECK_SUBNODES;
	}
	reduce_graph_recursive($node->{subgraph});
}

sub reduce_graph_recursive
{
	my $graph = shift;
	for my $node (values %$graph)
	{
		reduce_graph($node);
	}
}


reduce_graph_recursive($Graph);
output_subgraph 0, $Graph;
