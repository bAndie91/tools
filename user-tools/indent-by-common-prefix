#!/usr/bin/env perl

=pod

=head1 NAME

indent-by-common-prefix - short description

=head1 SYNOPSIS

indent-by-common-prefix [I<OPTIONS>]

=head1 DESCRIPTION

Reads lines on STDIN and replaces common prefixes by B<TAB>-indentation.

=head1 OPTIONS

=over 4

=item -d, --delimiter I<PATTERN>

Tokenize input lines by I<PATTERN> regexp pattern.
Default is any whitespace (C<\s+>).

=item -i, --indent-mark I<STRING>

Indent output by I<STRING>.
Default is B<TAB>.
Other useful I<STRING> are for example space, and double space.

=back

=head1 ENVIRONMENT

=head1 LIMITATIONS

=head1 SEE ALSO

indent2graph(1), indent2tree(1), paths2indent(1)

=cut


use Data::Dumper;
use utf8;
use open ':std', ':utf8';  # mark stdio as utf8 but not verify
use open ':utf8';
use Getopt::Long qw/:config no_ignore_case no_bundling no_getopt_compat no_auto_abbrev pass_through permute/;
use List::MoreUtils qw/all any none/;
use Pod::Usage;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';


$OptDelimiter = qr/\s+/;
$OptIndentMark = "\t";

GetOptions(
	'd|delimiter=s' => \$OptDelimiter,
	'i|indent-mark=s' => \$OptIndentMark,
	'help' => sub { pod2usage(-exitval=>0, -verbose=>99); },
	'<>' => sub { unshift @ARGV, $_[0]; die '!FINISH'; },
) or pod2usage(-exitval=>2, -verbose=>99);


$Graph = {};

while(<STDIN>)
{
	chomp;
	my @tokens = split $OptDelimiter;
	
	my $subgraph = $Graph;
	for my $token (@tokens)
	{
		if(not exists $subgraph->{$token})
		{
			$subgraph->{$token} = {
				label => $token,
				subgraph => {},
				nth_child => (scalar keys %$subgraph),
				parent => $subgraph,
			};
		}
		$subgraph = $subgraph->{$token}->{subgraph};
	}
}

#print Dumper $Graph;

sub subnodes
{
	my $graph = shift;
	return scalar keys %$graph;
}

sub output_subgraph;
sub output_subgraph
{
	my $indent_level = shift;
	my $graph = shift;
	
	for my $node (sort {$a->{nth_child} <=> $b->{nth_child}} values %$graph)
	{
		my $subgraph = $node->{subgraph};
		#printf "%s%d %s (%d subnodes)\n", $OptIndentMark x $indent_level, $node->{nth_child}, $node->{label}, subnodes $subgraph;
		printf "%s%s\n", $OptIndentMark x $indent_level, $node->{label};
		output_subgraph $indent_level+1, $subgraph;
	}
}

sub reduce_graph
{
	my $node = shift;
	REDUCE_CHECK_SUBNODES:
	my @subkeys = keys %{$node->{subgraph}};
	if(scalar @subkeys == 1)
	{
		my $subnode = $node->{subgraph}->{$subkeys[0]};
		$node->{subgraph} = $subnode->{subgraph};
		
		# TODO preserve literal delimiter substring
		my $new_label = $node->{label} . $OptDelimiter . $subnode->{label};
		# TODO check {$new_label}
		$node->{parent}->{$new_label} = $node;
		delete $node->{parent}->{ $node->{label} };
		$node->{label} = $new_label;
		goto REDUCE_CHECK_SUBNODES;
	}
	reduce_graph_recursive($node->{subgraph});
}

sub reduce_graph_recursive
{
	my $graph = shift;
	for my $node (values %$graph)
	{
		reduce_graph($node);
	}
}


reduce_graph_recursive($Graph);
output_subgraph 0, $Graph;
