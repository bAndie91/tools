#!/usr/bin/env perl

=pod

=head1 NAME

saveout - Save a programm's output to dynamically named files

=head1 SYNOPSIS

saveout I<OPTIONS> [--] I<COMMAND> [I<ARGS>]

=head1 DESCRIPTION

Run I<COMMAND> and redirect its STDOUT, and/or STDERR, and/or other file descriptors,
line-by-line, to dynamically named files.
Always append to output files.
Useful for eg. to save logs of a long running command (service) in separate files per day.

You can set flush rules (see below) for each output (STDOUT, STDERR, specific FD...).
A particular file is always flushed when the filename of the given output changes
(as the old file is closed).
Output is written per complete lines, so don't expect long data not delimited by B<linefeed> to appear chunk-by-chunk,
even with bytes- or time-based flushing.
Only B<linefeed> is taken as line terminator, not even a sole B<carriage-return>.

=head1 OPTIONS

=over 4

=item --out I<TEMPLATE>

Equivalent to --fd-1 I<TEMPLATE>.

=item --err I<TEMPLATE>

Equivalent to --fd-2 I<TEMPLATE>.

=item --fd-I<N> I<TEMPLATE>

Write I<COMMAND>'s output on the I<N>th file descriptor (STDOUT, STDERR, ...)
to a file of which path and name is constructed according to I<TEMPLATE>.
I<TEMPLATE> may contain the following macros:

=over 8

=item time macros

Support all strftime(3) macros, eg. B<%c>, B<%s>, B<%F>, B<%T>, ...

=item %[pid]

The PID of the process running I<COMMAND>.

=item %[substr:I<POS>[:I<LEN>]]

The line's substring at the given I<POS> position and I<LEN> length,
or to the end of line (excluding the terminating B<linefeed> char) if B<:>I<LEN> is not given.
Both I<POS> and I<LEN> can be negative;
see B<perldoc -f substr> for details.

B<Beware of potential unwanted path traversal!>
Make sure that the resulting file path does not go outsite of the directory you intended to write,
by eg. output, controlled by untrusted party, containing something like C<../../../etc/>.

=item %[regex:I<PATTERN>:I<CAPTURE>]

Not implemented.

=item %[perl:I<EXPR>]

Not implemented.

=back

=item -L, --flush-lines [I<LINES>]

Flush output files after I<LINES> number of lines.
Flush per each line if I<LINES> is not given (default I<LINES> is 1).
By default, leaves flushing to the underlaying IO layer, which usually buffers 4-8k blocks.
If you want to set different flushing rules on different outputs,
othen than buffered-IO or other than the default given by B<-L> option,
override by B<-Lo>, B<-Le>, and/or B<-Ln>.
See below.

=item -Lo, --flush-lines-stdout [I<LINES>]

Equivalent to C<< -Ln 1=I<LINES> >>.

=item -Le, --flush-lines-stdout [I<LINES>]

Equivalent to C<< -Ln 2=I<LINES> >>.

=item -Ln, --flush-lines-fd I<FD>[=I<LINES>]

Set file descriptor I<FD>'s output to be flushed by each I<LINES> lines.
Default I<LINES> is 1.

=item -B, --flush-bytes I<BYTES>

=item -Bo, --flush-bytes-stdout I<BYTES>

=item -Bo, --flush-bytes-stderr I<BYTES>

=item -Bn, --flush-bytes-fd I<FD>[=I<BYTES>]

Similar to the B<--flush-lines> option group,
except flush after at least I<BYTES> bytes are written to the selected outputs.
Maybe does not make sense to set more than the buffered-IO block size.

=item -S, --flush-sec I<SEC>

=item -So, --flush-sec-stdout I<SEC>

=item -So, --flush-sec-stderr I<SEC>

=item -Sn, --flush-sec-fd I<FD>[=I<SEC>]

Similar to the B<--flush-lines> and B<--flush-bytes> option groups,
except flush after at least I<SEC> seconds passed since last write to the selected outputs.

=item -f, --failure I<ACTION>

If can not write to the output file, or can not even open it,
print the failed line of text to its own STDERR,
then depending on the I<ACTION>:

=over 4

=item TERM

Terminate I<COMMAND> by SIGTERM, then continue running,
but will also exit soon as I<COMMAND> probably terminates upon the signal.
This is the default.

=item PIPE

Send SIGPIPE to I<COMMAND>, then continue running.
I<COMMAND> may recover from the error condition itself.

=item IGNORE

Just ignore.

=back

=back

=head1 SECURITY

See the above comment on C<%[substr]> template macro.

=head1 SEE ALSO

savelog(8), logto(1), stdsyslog(1), loggerexec(1), redirexec(1), logger(1), stdfilt(1)

=cut



use Data::Dumper;
use Getopt::Long qw/:config no_ignore_case no_bundling no_getopt_compat no_auto_abbrev/;
use Fcntl qw/F_GETFL F_SETFL O_NONBLOCK/;
use POSIX qw/strftime :sys_wait_h dup2/;
use Pod::Usage;
use List::MoreUtils qw/all any none/;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';


$0 = "saveout";
$Stream = {};
$OptDefaultFlush = {
	'lines' => undef,
	'bytes' => undef,
	'sec' => undef,
};
@FailureActions = ('TERM', 'PIPE', 'IGNORE');
$OptFailAction = $FailureActions[0];

@args = ();
while(@ARGV)
{
	my $arg = shift @ARGV;
	$arg =~ s/^(--fd)-(\d+)=/$1=$2=/;
	if($arg =~ /^--fd-(\d+)$/)
	{
		push @args, '--fd', "$1=" . (shift @ARGV);
		next;
	}
	push @args, $arg;
}
@ARGV = @args;

sub die_invalid_option_argument
{
	die "Invalid argument for ".$_[0]->{starter}.$_[0]->{given}." option: '".$_[1]."'\n";
}

sub set_flush_opt
{
	my $by = shift;
	if($_[1] =~ /^(\d+)(?:=(\d+)|)$/)
	{
		$Stream->{$1}->{'flush-by'}->{$by} = $2//1;
	}
	else
	{
		die_invalid_option_argument(@_);
	}
}

GetOptions(
	'o|out=s' => \$Stream->{1}->{'output'}->{'template'},
	'e|err=s' => \$Stream->{2}->{'output'}->{'template'},
	'fd=s' => sub {
		if($_[1] =~ /^(\d+)=(\S+)$/) {
			$Stream->{$1}->{'output'}->{'template'} = $2; }
		else {
			die_invalid_option_argument(@_); }
	},
	
	'L|flush-lines:+' => \$OptDefaultFlush->{'lines'},
	'Lo|flush-lines-stdout:+' => \$Stream->{1}->{'flush-by'}->{'lines'},
	'Le|flush-lines-stderr:+' => \$Stream->{2}->{'flush-by'}->{'lines'},
	'Ln|flush-lines-fd=s' => sub { set_flush_opt('lines', @_); },
	
	'B|flush-bytes:+' => \$OptDefaultFlush->{'bytes'},
	'Bo|flush-bytes-stdout:+' => \$Stream->{1}->{'flush-by'}->{'bytes'},
	'Be|flush-bytes-stderr:+' => \$Stream->{2}->{'flush-by'}->{'bytes'},
	'Bn|flush-bytes-fd=s' => sub { set_flush_opt('bytes', @_); },
	
	'S|flush-sec:+' => \$OptDefaultFlush->{'sec'},
	'So|flush-sec-stdout:+' => \$Stream->{1}->{'flush-by'}->{'sec'},
	'Se|flush-sec-stderr:+' => \$Stream->{2}->{'flush-by'}->{'sec'},
	'Sn|flush-sec-fd=s' => sub { set_flush_opt('sec', @_); },
	
	'f|fail|failure=s' => sub {
		if($_[1] ~~ @FailureActions) {
			$OptFailAction = $_[1]; }
		else {
			die_invalid_option_argument(@_); }
	},
	
	'help' => sub { pod2usage(-exitval=>0, -verbose=>99); },
	'<>' => sub { unshift @ARGV, @_[0]; die '!FINISH'; },
) or pod2usage(-exitval=>2, -verbose=>99);

for my $fd (keys %$Stream)
{
	delete $Stream->{$fd} unless defined $Stream->{$fd}->{'output'}->{'template'};
}

for my $by (keys %$OptDefaultFlush)
{
	if($OptDefaultFlush->{$by})
	{
		for my $s (values %$Stream)
		{
			$s->{'flush-by'}->{$by} = $OptDefaultFlush->{$by} unless defined $s->{'flush-by'}->{$by};
		}
	}
}



sub expand_template
{
	my $template = shift;
	my $line = shift;
	
	my $res = strftime($template, localtime);
	# strftime leaves "%[...]" as-is.
	$res =~ s{%\[pid\]}{$CHILD_PID}g;
	$res =~ s{%\[substr:(-?\d+)(?::(-?\d+))?\]}{substr $line, $1, $2||(length($line)-$1)}eg;
	return $res;
}

sub handle_failure
{
	my $msg = shift;
	my $fdnum = shift;
	my $linetext = shift;
	
	warn "$0: $msg\n";
	print STDERR "$0: fd $fdnum: can not save: $linetext";
	if($OptFailAction ~~ ['TERM', 'PIPE'])
	{
		kill $OptFailAction, $CHILD_PID;
	}
}

sub process_line
{
	my $line = shift;
	my $output = shift;
	my $flush_by = shift;
	
	my $output_file = expand_template($output->{'template'}, substr($line, 0, -1));
	if(defined $output->{'fh'} and $output_file ne $output->{'file'})
	{
		close_output($output);
	}
	if(not defined $output->{'fh'} or $output_file ne $output->{'file'})
	{
		my $open_ok = open $output->{'fh'}, '>>', $output_file;
		if(not $open_ok)
		{
			handle_failure("open: $output_file: $!", $output->{'child_fdnum'}, $line);
			return 0;
		}
		$output->{'file'} = $output_file;
	}
	
	$! = 0;
	my $write_ok = print {$output->{'fh'}} $line;
	if(not $write_ok)
	{
		handle_failure("write: $output_file: $!", $output->{'child_fdnum'}, $line);
		return 0;
	}
	
	if($flush_by->{'bytes'})
	{
		$output->{'written_bytes'} += length $line;
		if($flush_by->{'bytes'} <= $output->{'written_bytes'})
		{
			do_flush($output);
			$output->{'written_bytes'} = 0;
		}
	}
	if($flush_by->{'lines'})
	{
		$output->{'written_lines'} += 1;
		if($flush_by->{'lines'} <= $output->{'written_lines'})
		{
			do_flush($output);
			$output->{'written_lines'} = 0;
		}
	}
	if($flush_by->{'sec'} and not defined $output->{'flush_at'})
	{
		$output->{'flush_at'} = time + $flush_by->{'sec'};
	}
	return 1;
}

sub do_flush
{
	my $output = shift;
	$output->{'fh'}->flush;
	$output->{'flush_at'} = undef;
}

sub close_output
{
	my $output = shift;
	do_flush($output);
	close $output->{'fh'};
	$output->{'fh'} = undef;
	$output->{'written_bytes'} = 0;
	$output->{'written_lines'} = 0;
}

sub process_stream
{
	my $stream = shift;
	while(1)
	{
		my $nlpos = index $stream->{'buf'}, "\n";
		last if $nlpos == -1;  # ain't a complete line there
		$nlpos++;
		
		my $line = substr $stream->{'buf'}, 0, $nlpos;
		my $line_put_ok = process_line $line, $stream->{'output'}, $stream->{'flush-by'};
		# maybe keep the line in the buffer unless $line_put_ok?
		# this either blocks subsequent lines to be sent to output,
		# or mixes up the order and/or timestamping of reprocessed lines.
		
		$stream->{'buf'} = substr $stream->{'buf'}, $nlpos;
	}
}



for my $fdnum (keys %$Stream)
{
	pipe(my $reader, my $writer) or die "$0: pipe: $!\n";
	$Stream->{$fdnum}->{'reader'} = $reader;
	$Stream->{$fdnum}->{'writer'} = $writer;
	$Stream->{$fdnum}->{'buf'} => '';
	$Stream->{$fdnum}->{'output'}->{'file'} = '';
	$Stream->{$fdnum}->{'output'}->{'fh'} = undef;
	$Stream->{$fdnum}->{'output'}->{'child_fdnum'} = $fdnum;
}


$CHILD_PID = fork // die "$0: fork: $!\n";

if($CHILD_PID == 0)
{
	for my $fdnum (keys %$Stream)
	{
		my $writer_fd = fileno($Stream->{$fdnum}->{'writer'});
		dup2($writer_fd, $fdnum) or die "$0: dup2: $writer_fd: $!\n";
		close $Stream->{$fdnum}->{'reader'};
	}	
	
	exec {$ARGV[0]} @ARGV;
	my ($errno, $errstr) = (int $!, $!);
	warn "$0: ${ARGV[0]}: $errstr\n";
	exit 125+$errno;
}


my $child_status = undef;
close STDIN;
for my $fdnum (keys %$Stream)
{
	fcntl($Stream->{$fdnum}->{'reader'}, F_SETFL, fcntl($Stream->{$fdnum}->{'reader'}, F_GETFL, 0) | O_NONBLOCK);
	close $Stream->{$fdnum}->{'writer'};
}	



while(1)
{
	$fds = '';
	for my $fdnum (keys %$Stream)
	{
		vec($fds, fileno($Stream->{$fdnum}->{'reader'}), 1) = 1 if defined $Stream->{$fdnum}->{'reader'};
	}
	last if $fds eq '';
	
	my $timeout = undef;
	my ($earliest_scheduled_flush) = sort grep {defined} map { $_->{'output'}->{'flush_at'} } values %$Stream;
	$timeout = $earliest_scheduled_flush - time if defined $earliest_scheduled_flush;
	
	$! = 0;
	select($fds, undef, undef, $timeout);
	my $select_errno = int $!;
	
	# flush scheduled outputs, if any
	my $now = time;
	for my $stream (values %$Stream)
	{
		if(defined $stream->{'output'}->{'flush_at'} and $stream->{'output'}->{'flush_at'} <= $now)
		{
			do_flush($stream->{'output'});
		}
	}
	
	next if $select_errno;
	
	for my $stream (values %$Stream)
	{
		my $reader = $stream->{'reader'};
		if(vec($fds, fileno($reader), 1) == 1)
		{
			my $bytes = sysread $reader, $stream->{'buf'}, 1024, length $stream->{'buf'};
			if($bytes)
			{
				process_stream($stream);
			}
			else
			{
				# this stream is closed.
				undef $stream->{'reader'};
				# process last unterminated line (if any)
				process_line($stream->{'buf'}, $stream->{'output'}, $stream->{'flush-by'}) if length $stream->{'buf'};
				close_output($stream->{'output'});
			}
		}
	}
}

waitpid($CHILD_PID, 0);
$child_status = $?;
$exit_status = WEXITSTATUS($child_status);
$exit_status = 128 + WTERMSIG($child_status) if WIFSIGNALED($child_status);
exit $exit_status;
