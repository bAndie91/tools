#!/usr/bin/env perl

=pod

=head1 NAME

untabularize - Revert the formatting done by tabularize(1)

=head1 SYNOPSIS

untabularize [I<OPTIONS>]

=head1 DESCRIPTION

=head1 OPTIONS

=over 4

=item -P, --no-pipe-in-header

Expect no pipe char (C<|>) in column names,
so it's less ambiguous to determine vertical gridlines.

=item -p, --padding I<NUM>

Untabularize the input as it was tabularized by B<< -p I<NUM> >> padding.

=item -w, --allow-whitespace

Strip leading whitespace in column names to learn each column's left margin.

=item -F, --no-trim-filler

Don't remove trailing (or leading, in case of right-aligned cells) space,
which is often just a filler.

=back

=head1 LIMITATIONS

Does not reliably distinguish filler space from semantically significant space,
so it's either sometimes significant space gets removed
or filler space left there (with B<-F> option).
The default mode is to trim space in cell data from the right, if any,
else trim at the left.
The padding, if specified by B<-p> option, is always trimmed (even if it's non-space).

=head1 SEE ALSO

tabularize(1)

=cut


use Data::Dumper;
use Getopt::Long qw/:config no_ignore_case no_bundling no_getopt_compat no_auto_abbrev require_order/;
use List::MoreUtils qw/all any none/;
use Pod::Usage;
use POSIX;
no if ($] >= 5.018), 'warnings' => 'experimental::smartmatch';
use utf8;
use open ':std', ':utf8';

$OptNoPipeInHeader = 0;
$OptAllowWhitespace = undef;
$OptPadding = undef;
$OptTrimFiller = 1;

GetOptions(
	'help' => sub { pod2usage(-exitval=>0, -verbose=>99); },
	'P|no-pipe-in-header!' => \$OptNoPipeInHeader,
	'w|allow-whitespace!' => \$OptAllowWhitespace,
	'p|padding=i' => \$OptPadding,
	'F|no-trim-filler!' => sub { $OptTrimFiller = 0; },
	'<>' => sub { unshift @ARGV, @_[0]; die '!FINISH'; },
) or pod2usage(-exitval=>2, -verbose=>99);

if(defined $OptAllowWhitespace and defined $OptPadding)
{
	die "$0: options --allow-whitespace and --padding are mutually exclusive.\n";
}


while(<STDIN>)
{
	chomp;
	
	if(/^(┌|├|└|\+)(.)/ and not @cellWidths)
	{
		# determine how wide are each columns.
		
		my $linechar = $2;
		s/^[^\Q$linechar\E]//;
		s/[^\Q$linechar\E]$//;
		@cellWidths = map {length} split /[^\Q$linechar\E]/;
		next;
	}
	
	if(/^(\||│)/)
	{
		my $gridchar = $1;
		s/^\Q$gridchar\E//;
		s/\Q$gridchar\E$//;
		if(not @cellWidths)
		{
			if($gridchar eq '|' and !$OptNoPipeInHeader)
			{
				# pipe char may occur in the cell data as well,
				# so can not confidentally take it as a cell separator.
				die "$0: can not determine the columns in --ascii --no-horizontal mode\n".
				    "$0: consider --no-pipe-in-header option.\n";
			}
			@cellWidths = map {length} split /\Q$gridchar\E/;
		}
		my $record = $_;
		my $prev_cell_endpos = 0;
		my @cells = map
			{
				my $cell = substr $record, $prev_cell_endpos, $_;
				$prev_cell_endpos += $_ + length $gridchar;
				$cell;
			}
			@cellWidths;
			
		if($OptAllowWhitespace and not @leftMargins)
		{
			# @leftMargins is not yet defined so it must be the header line.
			# determining the left-side whitespace padding form the column names in the header:
			@leftMargins = map {/^(\s*)/; length $1} @cells;
		}
		if(@leftMargins)
		{
			# remove at most leftMargin number of spaces.
			# so outdented cells won't be truncated,
			# and indented ones keep the indentation relative to the column header.
			$cells[$_] =~ s/^[ ]{0,$leftMargins[$_]}// for 0 .. $#cells;
		}
		if($OptPadding)
		{
			@cells = map { substr $_, $OptPadding, -$OptPadding } @cells;
		}
		
		if($OptTrimFiller)
		{
			# strip trailing (or leading if the cell is right-aligned) whitespace.
			#
			# note, it wrongly removes leading whitespace in left-aligned columns if the cell data runs all the way to the right border,
			# but has a significant leading space (for example hierarchy denoted by indentation).
			# and similarly in right-aligned columns if the cell data starts all the way at the left border
			# but has space at the end (for example decimal numbers with vertically aligned place values).
			@cells = map { s/\s+$// or s/^\s+//; $_ } @cells;
		}
		
		print join("\t", @cells) . "\n";
	}
}
