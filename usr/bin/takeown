#!/bin/bash

. /usr/lib/yazzy-utils/bash-utils || exit 1

verbose()
{
	local cmd=$1
	shift
	command "$cmd" ${verbose:+-v} "$@"
}

run()
{
	if [ "$dryrun" = yes ]
	then
		[ "$1" != verbose ] || shift
		echo "$@"
	else
		"$@"
	fi
}

debug()
{
	[ "$debug" != yes ] || warnx "$@"
}

warnx()
{
	echo "$PROGNAME: $*" >&2
}

yesno()
{
	"$@" && echo yes || echo no
}

is_empty_directory()
{
	local a=`find "$1" -mindepth 1 -print -quit`
	if [ -z "$a" ]
	then
		return 0
	else
		return 1
	fi
}

is_writable_dir()
{
	if [ "$activewritetest" = yes ]
	then
		local testfile=''
		local werr=''
		while [ -z "$testfile" -o -e "$testfile" ]
		do
			testfile=$1/takeown-writetest.$RANDOM
		done
		werr=`touch "$testfile"; echo $?`
		[ ! -e "$testfile" ] || rm "$testfile" || true
		return $werr
	else
		return `[ -w "$1" ]; echo $?`
	fi
}

is_recursive()
{
	return `[ "$recursive" = yes ]; echo $?`
}

strip_trailing_slashes()
{
	local str=$1
	while [ "${str: -1}" = / ]
	do
		str=${str%/}
	done
	echo "$str"
}

strict()
{
	return `[ "${strict[$1]}" = yes ]; echo $?`
}

no_strict()
{
	if [ $silent_strictness_check != yes ]
	then
		warnx "Can not clone file's $1: $2"
	fi
	return `[ "${strict[$1]}" != yes ]; echo $?`
}

sort_by_length_desc()
{
	local x
	local y
	local index
	local shiftindex
	declare -a -g sort_by_length_desc_result
	sort_by_length_desc_result=()
	
	for x in "$@"
	do
		index=0
		for y in "${sort_by_length_desc_result[@]}"
		do
			if [ ${#y} -le ${#x} ]
			then
				shiftindex=${#sort_by_length_desc_result[@]}
				while [ $shiftindex -ge $index ]
				do
					sort_by_length_desc_result[$shiftindex]=${sort_by_length_desc_result[shiftindex - 1]}
					shiftindex=$[shiftindex - 1]
				done
				break
			fi
			index=$[index + 1]
		done
		sort_by_length_desc_result[$index]=$x
	done
}

main()
{
	local argv
	argv=("$@")
	
	if ! is_recursive
	then
		# Sort CLI arguments to make "dir1/file1" files processed earlier than "dir1/".
		sort_by_length_desc "${argv[@]}"
		declare -a argv
		argv=("${sort_by_length_desc_result[@]}")
	fi
	
	local file
	for file in "${argv[@]}"
	do
		file=`strip_trailing_slashes "$file"`
		
		local owner=`stat -c %u "$file"`
			
		if [ "$owner" != "$UID" ]
		then
			if [ -L "$file" ]
			then
				takeown symlink "$file"
			elif [ -d "$file" ]
			then
				takeown directory "$file"
			else
				takeown file "$file"
			fi
		fi
	done
}

subs_file_comment()
{
	# Replace filename in lines like: `# file: ...´
	sed -e "s@^# file:.*@# file: ${1//@/\@}@"
}

copy_attributes()
{
	if [ "$dochgrp" = yes ]
	then
		run verbose chgrp --quiet --reference="$1" --no-dereference "$2" || no_strict group "$1"
	fi
	run verbose chmod --quiet --reference="$1" "$2" || no_strict mode "$1"
	getfacl --skip-base "$1" | subs_file_comment "$2" | run setfacl --restore=- || no_strict acl "$1"
	getfattr --no-dereference --physical --dump "$1" | subs_file_comment "$2" | run setfattr --restore=- || no_strict xattr "$1"
	# TODO support ext2 attributes
}

takeown()
{
	#  the file/directory to be taken own
	local TAKEOWN_FILE=$2
	#  the file/directory to be a clone of TAKEOWN_FILE (and supersede thereafter)
	local TAKEOWN_COPY=$2.takeown
	#  the file/directory TAKEOWN_FILE will be renamed to, can be used as backup
	local TAKEOWN_BACK=$2.tookown
	
	debug "${FUNCNAME[0]}-$1 $2"
	
	# Run individual takeown procedures in subshell to avoid cascade exception.
	(
		case "$1" in
		symlink)
			takeown_symlink
			;;
		file)
			takeown_file
			;;
		directory)
			takeown_directory
			;;
		esac
	)
	local ec=$?
	if [ $ec != 0 ]
	then
		if [ "$ignoreerrors" = yes ]
		then
			Error=$ec
		else
			exit $ec
		fi
	fi
}

cleanup()
{
	warnx "Error happened. Reverting changes..."
	
	case "$1" in
	symlink)
		run verbose rm --force "$TAKEOWN_COPY"
		;;
	file)
		run verbose rm --force "$TAKEOWN_COPY"
		;;
	directory)
		local idx
		
		# TODO turn off errfail ?
		
		if [ $erase_on_fail = yes ]
		then
			warnx "Removing copies..."
			idx=$[ ${#files_copied_out_trg[@]} - 1 ]
			for ((; idx>=0; idx--))
			do
				run verbose rm --force "${files_copied_out_trg[idx]}"
			done
			
			warnx "Moving back moved files..."
			idx=$[ ${#files_moved_out_trg[@]} - 1 ]
			for ((; idx>=0; idx--))
			do
				run verbose mv --force --no-target-directory "${files_moved_out_trg[idx]}" "${files_moved_out_src[idx]}"
			done
			
			warnx "Removing created directories..."
			idx=$[ ${#dirs_created[@]} - 1 ]
			for ((; idx>=0; idx--))
			do
				run verbose rmdir "${dirs_created[idx]}"
			done
		fi
		
		# the last step of taking own a directory is to replace TAKEOWN_FILE with TAKEOWN_COPY.
		# until this step we're working on and in TAKEOWN_COPY, 
		# so it's save to remove it.
		if [ -e "$TAKEOWN_COPY" ]
		then
			run verbose rmdir "$TAKEOWN_COPY"
		fi
		
		if [ -e "$TAKEOWN_BACK" ]
		then
			run verbose mv --force --no-target-directory "$TAKEOWN_BACK" "$TAKEOWN_FILE"
		fi
		
		# clear arrays for the processing of the next cli argument
		files_copied_out_src=()
		files_copied_out_trg=()
		files_moved_out_src=()
		files_moved_out_trg=()
		dirs_created=()
		;;
	esac
}

takeown_symlink()
{
	try --except "cleanup symlink"
		copy_out_symlink "$TAKEOWN_FILE" "$TAKEOWN_COPY"
		run verbose mv --force --no-target-directory "$TAKEOWN_COPY" "$TAKEOWN_FILE"
	untry
}

takeown_file()
{
	try --except "cleanup file"
		copy_out_file "$TAKEOWN_FILE" "$TAKEOWN_COPY"
		run verbose mv --force --no-target-directory "$TAKEOWN_COPY" "$TAKEOWN_FILE"
	untry
}

register_moved_file()
{
	files_moved_out_src+=("$1")
	files_moved_out_trg+=("$2")
}

register_created_dir()
{
	dirs_created+=("$1")
}

copy_out()
{
	local filetype=$1
	shift
	
	case "$filetype" in
	symlink)
		copy_out_symlink "$@"
		;;
	file)
		copy_out_file "$@"
		;;
	*)
		warnx internal error: copy_out $filetype "$@"
		exit 1
		;;
	esac
	
	files_copied_out_src+=("$1")
	files_copied_out_trg+=("$2")
}

copy_out_file()
{
	local src=$1
	local trg=$2
	
	run touch --reference="$src" "$trg"
	# setup a mode just enough to able to write. clone all attributes later.
	chmod 0600 "$trg"
	run verbose cp --no-dereference --preserve=all --force --no-target-directory "$src" "$trg"
	copy_attributes "$src" "$trg"
}

copy_out_symlink()
{
	local src=$1
	local trg=$2
	
	local symlink_target=`readlink "$src"`
	run verbose ln --symbolic --no-target-directory --force "$symlink_target" "$trg"
	run touch --no-dereference --reference="$src" "$trg"
	# symlinks does not seem to capable to carry ACLs on my system.
	# I get EPERM on lsetxattr(2) on symlinks too.
}

takeown_a_directory()
{
	local src=$1
	local trg=$2
	local src_back=$3
	local do_supersede=$4
	local subfile
	local owner
	local is_writable_src
	
	run verbose install -m 0700 -d "$trg"
	# delay cloning attibutes to prevent unlucky cases
	# such as "u-w" permissions on the directory
	
	register_created_dir "$trg"
	
	if is_recursive
	then
		for subfile in "$src"/*
		do
			subfile=${subfile##*/}
			owner=`stat -c %u "$src/$subfile"`
			is_writable_src=`yesno is_writable_dir "$src"`
			
			if [ -L "$src/$subfile" ]
			then
				if [ "$owner" = "$UID" -a $is_writable_src = yes ]
				then
					run verbose mv --force --no-target-directory "$src/$subfile" "$trg/$subfile"
					register_moved_file "$src/$subfile" "$trg/$subfile"
				else
					copy_out symlink "$src/$subfile" "$trg/$subfile"
				fi
				
			elif [ -d "$src/$subfile" ]
			then
				# directories must be writable in order to be moved 
				# into an other parent directory
				if [ "$owner" = "$UID" -a $is_writable_src = yes ]
				then
					# temporary allow the current user to write her own directory
					# to able to move to other parent directory
					local modes=`stat -c %a "$src/$subfile"`
					chmod u+w "$src/$subfile" || [ -w "$src/$subfile" ]
					local moved
					if run verbose mv --force --no-target-directory "$src/$subfile" "$trg/$subfile"
					then
						moved=yes
						# restore permission modes on $subfile (now it's in $trg directory)
						chmod 0$modes "$trg/$subfile"
						register_moved_file "$src/$subfile" "$trg/$subfile"
					else
						moved=no
						# restore permission modes on $subfile (stayd in $src directory)
						chmod 0$modes "$src/$subfile"
					fi
					test $moved = yes
				else
					takeown_a_directory "$src/$subfile" "$trg/$subfile" "" no
				fi
			
			elif [ "$owner" = "$UID" -a $is_writable_src = yes ]
			then
				run verbose mv --force --no-target-directory "$src/$subfile" "$trg/$subfile"
				register_moved_file "$src/$subfile" "$trg/$subfile"
			else
				copy_out file "$src/$subfile" "$trg/$subfile"
			fi
		done
	fi
	
	copy_attributes "$src" "$trg"
	
	if [ "$do_supersede" = yes ]
	then
		if [ -n "$src_back" ]
		then
			if ! is_empty_directory "$src"
			then
				run verbose mv --force --no-target-directory "$src" "$src_back"
			fi
		fi
		
		run verbose mv --force --no-target-directory "$trg" "$src"
	fi
}

takeown_directory()
{
	local do_supersede=yes
	
	try --except "cleanup directory"
		takeown_a_directory "$TAKEOWN_FILE" "$TAKEOWN_COPY" "$TAKEOWN_BACK" $do_supersede
	untry
}



shopt -s dotglob
shopt -s nullglob

PROGNAME=takeown
verbose=''
debug=''
dryrun=''
recursive=''
declare -A strict
strict=([mode]='' [group]='' [acl]='' [xattr]='')
dochgrp=yes
ignoreerrors=''
activewritetest=''
silent_strictness_check=no
erase_on_fail=no
besteffort=no


while [ -n "$1" ]
do
	case "$1" in
	-h|--help)
		echo "Usage: takeown [options] <files>
Options:
 -D, --debug               debug
 -v, --verbose             verbose
 -n, --dry-run             dry run
 -i, --ignore              ignore failures on files given in command arguments
 -b, --best-effort         do what can be done, ignore failures (imply -i)
 -R, --recursive           recurse into directories
 -t, --strict              strict chmod, chgrp, setfacl, setfattr
 -M, --no-strict-chmod     different mode does not matter
 -G, --no-strict-chgrp     different group does not matter
 -A, --no-strict-setfacl   different ACL does not matter
 -X, --no-strict-setfattr  different extended attributes do not matter
 -g, --no-chgrp            do not chgrp at all
 -w, --active-write-test   active write test (instead of access(2))
 --erase-on-failure        remove copies when taking own a directory is failed
Exit code:
 0    all operations succeeded
 1+   error happended during progress, even it was ignored"
		exit 0
		;;
	-v|--verbose)
		verbose=yes
		;;
	-D|--debug)
		debug=yes
		;;
	-n|--dry-run)
		dryrun=yes
		;;
	--erase-on-fail|--erase-on-failure)
		erase_on_fail=yes
		;;
	-b|--best-effort)
		besteffort=yes
		# TODO implement
		;;
	-R|--recursive)
		recursive=yes
		;;
	-g|--no-group|--no-chgrp)
		dochgrp=no
		;;
	-i|--ignore)
		ignoreerrors=yes
		;;
	-t|--strict)
		for s in ${!strict[@]}
		do
			[ -z "${strict[$s]}" ] && strict[$s]=yes
		done
		;;
	-M|--no-strict-mode|--no-strict-modes|--no-strict-chmod)
		strict[mode]=no
		;;
	-G|--no-strict-group|--no-strict-chgrp)
		strict[group]=no
		;;
	-A|--no-strict-acl|--no-strict-setfacl)
		strict[acl]=no
		;;
	-X|--no-strict-xattr|--no-strict-setfattr)
		strict[xattr]=no
		;;
	-w|--active-write-test)
		activewritetest=yes
		;;
	-*)
		errx 1 "Unknown option: $1"
		;;
	--)
		shift
		break
		;;
	*)
		break
		;;
	esac
	shift
done

declare -g Error=0
declare -a files_copied_out_src
declare -a files_copied_out_trg
declare -a files_moved_out_src
declare -a files_moved_out_trg
declare -a dirs_created

main "$@"
exit $Error



true <<EOF

=pod

=head1 NAME

takeown - Take ownership on files, even for unprivileged users

=head1 SYNOPSIS

takeown [I<options>] <I<files> and I<directories>>

=head1 DESCRIPTION

chown(2) is permitted only for root (and processes with CAP_CHOWN), but normal users can emulate this behavior.
You can copy other users´ file for your own in a directory writable by you, and then replace the original file with your copy.
It is quite tricky and expensive sometimes, but gives you an option.
Say, when somebody forgot to use the right user account when saving files directly to your folders.

=cut

EOF

