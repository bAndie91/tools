#!/bin/bash

. /usr/lib/yazzy-utils/bash-utils || exit 1

verbose()
{
	local cmd=$1
	shift
	command "$cmd" ${verbose:+-v} "$@"
}

run()
{
	if [ "$dryrun" = yes ]
	then
		[ "$1" != verbose ] || shift
		echo "$@"
	else
		"$@"
	fi
}

debug()
{
	[ "$debug" = yes ] && warnx "$@"
}

warnx()
{
	echo "$PROGNAME: $*" >&2
}

is_empty_directory()
{
	local a=`find "$1" -mindepth 1 -print -quit`
	[ -z "$a" ]
}

is_writable()
{
	if [ "$activewritetest" = yes ]
	then
		local testfile=
		local werr=
		while [ -z "$testfile" -o -e "$testfile" ]
		do
			testfile=$1/takeown-writetest.$RANDOM
		done
		touch "$testfile"
		werr=$?
		[ -e "$testfile" ] && rm "$testfile"
		return $werr
	else
		[ -w "$1" ]
	fi
}

strip_trailing_slashes()
{
	local var=$1
	while [ "${!var: -1}" = / ]
	do
		local value=${!var%/}
		eval $var=\$value
	done
}

strict()
{
	[ "${strict[$1]}" = yes ]
}

no_strict()
{
	[ "${strict[$1]}" != yes ]
}

main()
{
	local file
	local owner
	
	for file in "$@"
	do
		strip_trailing_slashes file
		
		if [ -e "$file" ]
		then
			owner=`stat -c %u "$file"`
			
			if [ -L "$file" ]
			then
				if [ "$owner" != "$UID" ]
				then
					takeown symlink "$file"
				fi
			
			elif [ -d "$file" ]
			then
				if [ "$owner" != "$UID" ]
				then
					takeown directory "$file"
				fi
			
				if [ "$recursive" = yes ]
				then
					# Recurse into subdirectory.
					main "$file"/*
				fi
				
			elif [ "$owner" != "$UID" ]
			then
				takeown file "$file"
			fi
		
		else
			errx 1 "$file: not exists"
		fi
	done
}

subs_file_cmnt()
{
	# Replace filename in lines like: `# file: ...´
	sed -e "s@^# file:.*@# file: ${1//@/\@}@"
}

cpy_attr()
{
	if [ "$dochgrp" = yes ]
	then
		run verbose chgrp --quiet --reference="$1" --no-dereference "$2" || no_strict group
	fi
	run verbose chmod --quiet --reference="$1" "$2" || no_strict mode
	getfacl --skip-base "$1" | subs_file_cmnt "$2" | run setfacl --restore=- || no_strict acl
	getfattr --no-dereference --physical --dump "$1" | subs_file_cmnt "$2" | run setfattr --restore=- || no_strict xattr
}

takeown()
{
	local file=$2
	local copy=$2.takeown
	local back=$2.tookown
	
	debug "${FUNCNAME[0]}-$1 $2"
	
	(
		case "$1" in
		symlink)
			takeown_symlink
			;;
		file)
			takeown_file
			;;
		directory)
			takeown_directory
			;;
		esac
	)
	local ec=$?
	if [ $ec != 0 ]
	then
		if [ "$ignoreerrors" = yes ]
		then
			Error=$ec
		else
			exit $ec
		fi
	fi
}

cleanup()
{
	case "$1" in
	symlink)
		run verbose rm --force "$copy"
		;;
	file)
		run verbose rm --force "$copy"
		;;
	directory)
		run verbose rmdir "$copy"
		;;
	directory-recursive)
		run verbose rm -r "$copy"
		if [ -e "$back" ]
		then
			run verbose mv --force --no-target-directory "$back" "$file"
		fi
		;;
	esac
}

takeown_symlink()
{
	try --except "cleanup symlink"
		local target=`readlink "$file"`
		run verbose ln --symbolic --no-target-directory --force "$target" "$copy"
		run touch --no-dereference --reference="$file" "$copy"
		run verbose mv --force --no-target-directory "$copy" "$file"
	untry
}

takeown_file()
{
	try --except "cleanup file"
		run touch --reference="$file" "$copy"
		cpy_attr "$file" "$copy"
		run verbose cp --no-dereference --preserve=all --force "$file" "$copy"
		cpy_attr "$file" "$copy"
		run verbose mv --force "$copy" "$file"
	untry
}

takeown_directory()
{
	local group
	local modes
	group=`stat -c %G "$file"`
	modes=`stat -c %a "$file"`
	
	if is_writable "$file"
	then
		try --except "cleanup directory"
			run verbose install -m 0700 -d "$copy"
			if ! is_empty_directory "$file"
			then
				run verbose mv --force "$file"/* "$copy"
			fi
			cpy_attr "$file" "$copy"
		untry
		run verbose mv --force --no-target-directory "$copy" "$file"
	else
		try --except "cleanup directory-recursive"
			run verbose cp --recursive --no-dereference --preserve=all --no-preserve=ownership --no-target-directory --force "$file" "$copy"
			cpy_attr "$file" "$copy"
			if ! is_empty_directory "$file"
			then
				run verbose mv --force --no-target-directory "$file" "$back"
			fi
			run verbose mv --force --no-target-directory "$copy" "$file"
		untry
	fi
}



shopt -s dotglob
shopt -s nullglob

PROGNAME=takeown
verbose=
debug=
dryrun=
recursive=
declare -A strict
strict=([mode]= [group]= [acl]= [xattr]=)
dochgrp=yes
ignoreerrors=
activewritetest=


while [ -n "$1" ]
do
	case "$1" in
	-h|--help)
		echo "Usage: takeown [options] <files>
Options:
 -D, --debug               debug
 -v, --verbose             verbose
 -n, --dry-run             dry run
 -i, --ignore              ignore errors
 -R, --recursive           recurse into directories
 -t, --strict              strict chmod, chgrp, setfacl, setfattr
 -M, --no-strict-chmod     no strict chmod
 -G, --no-strict-chgrp     no strict chgrp
 -A, --no-strict-setfacl   no strict setfacl
 -X, --no-strict-setfattr  no strict setfattr
 -g, --no-chgrp            no chgrp at all
 -w, --active-write-test   active write test (instead of access(2))
Exit code:
 0    all operations succeeded
 1+   error happended during progress, even it was ignored"
		exit 0
		;;
	-v|--verbose)
		verbose=yes
		;;
	-D|--debug)
		debug=yes
		;;
	-n|--dry-run)
		dryrun=yes
		;;
	-R|--recursive)
		recursive=yes
		;;
	-g|--no-group|--no-chgrp)
		dochgrp=no
		;;
	-i|--ignore)
		ignoreerrors=yes
		;;
	-t|--strict)
		for s in ${!strict[@]}
		do
			[ -z "${strict[$s]}" ] && strict[$s]=yes
		done
		;;
	-M|--no-strict-mode|--no-strict-modes|--no-strict-chmod)
		strict[mode]=no
		;;
	-G|--no-strict-group|--no-strict-chgrp)
		strict[group]=no
		;;
	-A|--no-strict-acl|--no-strict-setfacl)
		strict[acl]=no
		;;
	-X|--no-strict-xattr|--no-strict-setfattr)
		strict[xattr]=no
		;;
	-w|--active-write-test)
		activewritetest=yes
		;;
	-*)
		errx 1 "Unknown option: $1"
		;;
	--)
		shift
		break
		;;
	*)
		break
		;;
	esac
	shift
done

declare -g Error=0
main "$@"
exit $Error



true <<EOF

=pod

=head1 NAME

takeown - Take ownership on files, also for unprivileged users

=head1 SYNOPSIS

takeown [I<options>] <I<files> and I<directories>>

=head1 DESCRIPTION

chown(2) is permitted only for root (and processes with CAP_CHOWN), but normal users can emulate this behavior.
You can copy others´ file for your own in a directory writable by you, and then replace the original file with your copy.
It is quite tricky and expensive sometimes, but gives solution for some cases.
Say, when somebody forgot to use the right user account when saving files directly to your folders.

=cut

EOF
