#!/bin/bash

. /usr/lib/yazzy-utils/bash-utils || exit 1

verbose()
{
	local cmd=$1
	shift
	command "$cmd" ${verbose:+-v} "$@"
}

run()
{
	if [ "$dryrun" = yes ]
	then
		[ "$1" != verbose ] || shift
		echo "$@" >&2
	else
		"$@"
	fi
}

debug()
{
	[ "$debug" != yes ] || warnx "$@"
}

warnx()
{
	echo "$PROGNAME: $*" >&2
}

yesno()
{
	"$@" && echo yes || echo no
}

is_empty_directory()
{
	local a=`find "$1" -mindepth 1 -print -quit`
	if [ -z "$a" ]
	then
		return 0
	else
		return 1
	fi
}

is_writable_dir()
{
	if [ "$dryrun" != yes -a "$activewritetest" = yes ]
	then
		local testfile=''
		local werr=''
		while [ -z "$testfile" -o -e "$testfile" ]
		do
			testfile=$1/takeown-writetest.$RANDOM
		done
		werr=`touch "$testfile"; echo $?`
		[ ! -e "$testfile" ] || rm "$testfile" || true
		return $werr
	else
		return `[ -w "$1" ]; echo $?`
	fi
}

is_recursive()
{
	return `[ "$recursive" = yes ]; echo $?`
}

besteffort_mode()
{
	return `[ "$besteffort" = yes]; echo $?`
}

strip_trailing_slashes()
{
	local str=$1
	while [ "${str: -1}" = / ]
	do
		str=${str%/}
	done
	echo "$str"
}

strict()
{
	return `[ "${strict[$1]}" = yes ]; echo $?`
}

no_strict()
{
	if [ $silent_strictness_check != yes ]
	then
		warnx "Can not clone file's $1: $2"
	fi
	return `[ "${strict[$1]}" != yes ]; echo $?`
}

sort_by_length_desc()
{
	local x
	local y
	local index
	local shiftindex
	declare -a -g sort_by_length_desc_result
	sort_by_length_desc_result=()
	
	for x in "$@"
	do
		index=0
		for y in "${sort_by_length_desc_result[@]}"
		do
			if [ ${#y} -le ${#x} ]
			then
				shiftindex=${#sort_by_length_desc_result[@]}
				while [ $shiftindex -ge $index ]
				do
					sort_by_length_desc_result[$shiftindex]=${sort_by_length_desc_result[shiftindex - 1]}
					shiftindex=$[shiftindex - 1]
				done
				break
			fi
			index=$[index + 1]
		done
		sort_by_length_desc_result[$index]=$x
	done
}

main()
{
	local argv
	argv=("$@")
	
	if ! is_recursive
	then
		# Sort CLI arguments to make "dir1/file1" files processed earlier than "dir1/".
		sort_by_length_desc "${argv[@]}"
		declare -a argv
		argv=("${sort_by_length_desc_result[@]}")
	fi
	
	local file
	for file in "${argv[@]}"
	do
		file=`strip_trailing_slashes "$file"`
		
		local owner=`stat -c %u "$file"`
		
		if [ "$owner" != "$UID" ]
		then
			if [ -L "$file" ]
			then
				takeown symlink "$file"
			elif [ -d "$file" ]
			then
				takeown directory "$file"
			else
				takeown file "$file"
			fi
		fi
	done
}

subs_file_comment()
{
	# Replace filename in lines like: `# file: ...´
	sed -e "s@^# file:.*@# file: ${1//@/\@}@"
}

takeown()
{
	#  the file/directory to be taken own
	local TAKEOWN_FILE=$2
	#  the file/directory to be a clone of TAKEOWN_FILE (and supersede thereafter)
	local TAKEOWN_COPY=$2.takeown
	#  the file/directory TAKEOWN_FILE will be renamed to (can be used as backup)
	local TAKEOWN_BACK=$2.tookown
	
	debug "${FUNCNAME[0]}-$1 $2"
	
	# clear tracking arrays
	files_copied_out_src=()
	files_copied_out_trg=()
	files_moved_out_src=()
	files_moved_out_trg=()
	dirs_created=()
	
	# Run individual takeown procedures in subshell to avoid cascade exception.
	(
		case "$1" in
		symlink)
			takeown_symlink
			;;
		file)
			takeown_file
			;;
		directory)
			takeown_directory
			;;
		esac
	)
	local ec=$?
	if [ $ec != 0 ]
	then
		if [ "$ignoreerrors" = yes ]
		then
			Error=$ec
		else
			exit $ec
		fi
	fi
}

cleanup()
{
	warnx "Error happened. Reverting changes..."
	
	case "$1" in
	symlink)
		run verbose rm --force "$TAKEOWN_COPY"
		;;
	file)
		run verbose rm --force "$TAKEOWN_COPY"
		;;
	directory)
		local idx
		
		if [ "$erase_on_fail" = yes ]
		then
			warnx "Removing copies..."
			idx=$[ ${#files_copied_out_trg[@]} - 1 ]
			for ((; idx>=0; idx--))
			do
				run verbose rm --force "${files_copied_out_trg[idx]}"
			done
			
			warnx "Moving back moved files..."
			idx=$[ ${#files_moved_out_trg[@]} - 1 ]
			for ((; idx>=0; idx--))
			do
				run verbose mv --force --no-target-directory "${files_moved_out_trg[idx]}" "${files_moved_out_src[idx]}"
			done
			
			warnx "Removing created directories..."
			idx=$[ ${#dirs_created[@]} - 1 ]
			for ((; idx>=0; idx--))
			do
				run verbose rmdir "${dirs_created[idx]}"
			done
		fi
		
		# the last step of taking own a directory is to replace TAKEOWN_FILE with TAKEOWN_COPY.
		# until this step we're working on and in TAKEOWN_COPY,
		# so it's save to remove it.
		if [ -e "$TAKEOWN_COPY" ]
		then
			run verbose rmdir "$TAKEOWN_COPY"
		fi
		
		if [ -e "$TAKEOWN_BACK" ]
		then
			run verbose mv --force --no-target-directory "$TAKEOWN_BACK" "$TAKEOWN_FILE"
		fi
		;;
	esac
}

takeown_symlink()
{
	try --except "cleanup symlink"
		copy_out_symlink "$TAKEOWN_FILE" "$TAKEOWN_COPY"
		run verbose mv --force --no-target-directory "$TAKEOWN_COPY" "$TAKEOWN_FILE"
	untry
}

takeown_file()
{
	try --except "cleanup file"
		copy_out_file "$TAKEOWN_FILE" "$TAKEOWN_COPY"
		run verbose mv --force --no-target-directory "$TAKEOWN_COPY" "$TAKEOWN_FILE"
	untry
}

register_moved_file()
{
	files_moved_out_src+=("$1")
	files_moved_out_trg+=("$2")
}

register_copied_file()
{
	files_copied_out_src+=("$1")
	files_copied_out_trg+=("$2")
}

register_created_dir()
{
	dirs_created+=("$1")
}

copy_attributes()
{
	local errstatus
	
	try
		set +e
		(
			set -e
			if [ "$dochgrp" = yes ]
			then
				run verbose chgrp --quiet --reference="$1" --no-dereference "$2" || no_strict group "$1"
			fi
			run verbose chmod --quiet --reference="$1" "$2" || no_strict mode "$1"
			getfacl --skip-base "$1" | subs_file_comment "$2" | run setfacl --restore=- || no_strict acl "$1"
			getfattr --no-dereference --physical --dump "$1" | subs_file_comment "$2" | run setfattr --restore=- || no_strict xattr "$1"
			# TODO support ext2 attributes
		)
		errstatus=$?
	untry
	
	if [ $errstatus != 0 ]
	then
		# either copy-attributes operation should succeed or we should be in best-effort mode
		besteffort_mode
	fi
	
	# return success. errors handled earlier.
	return 0
}

copy_out()
{
	local filetype=$1
	local errstatus
	shift
	
	# run in subshell to able to check best-effort mode
	try
		set +e
		(
			set -e
			case "$filetype" in
			symlink)
				copy_out_symlink "$@"
				;;
			file)
				copy_out_file "$@"
				;;
			*)
				warnx "internal error: copy_out $filetype $*"
				exit 1
				;;
			esac
		)
		errstatus=$?
	untry
	
	if [ $errstatus = 0 ]
	then
		register_copied_file "$1" "$2"
	else
		# either copy-out operation should succeed or we should be in best-effort mode
		besteffort_mode
	fi
	
	# return success. errors handled earlier.
	return 0
}

copy_out_file()
{
	local src=$1
	local trg=$2
	
	run touch --reference="$src" "$trg"
	# setup a mode just enough to able to write. clone all attributes later.
	run chmod 0600 "$trg"
	run verbose cp --no-dereference --preserve=all --force --no-target-directory "$src" "$trg"
	copy_attributes "$src" "$trg"
}

copy_out_symlink()
{
	local src=$1
	local trg=$2
	
	local symlink_target=`readlink "$src"`
	run verbose ln --symbolic --no-target-directory --force "$symlink_target" "$trg"
	run touch --no-dereference --reference="$src" "$trg"
	# symlinks does not seem to capable to carry ACLs on my system.
	# I get EPERM on lsetxattr(2) on symlinks too.
}

takeown_directory_recursive()
{
	local src=$1
	local trg=$2
	local src_back=$3
	local do_supersede=$4
	local subfile
	local owner
	local is_writable_src
	
	run verbose install -m 0700 -d "$trg"
	# delay cloning attibutes to prevent unlucky cases
	# such as "u-w" permissions on the directory
	
	register_created_dir "$trg"
	
	if is_recursive
	then
		for subfile in "$src"/*
		do
			subfile=${subfile##*/}
			owner=`stat -c %u "$src/$subfile"`
			is_writable_src=`yesno is_writable_dir "$src"`
			
			if [ -L "$src/$subfile" ]
			then
				if [ "$owner" = "$UID" -a $is_writable_src = yes ]
				then
					if run verbose mv --force --no-target-directory "$src/$subfile" "$trg/$subfile"
					then
						register_moved_file "$src/$subfile" "$trg/$subfile"
					else
						# either 'mv' should succeed or we should be in best-effort mode
						besteffort_mode
					fi
				else
					copy_out symlink "$src/$subfile" "$trg/$subfile"
					# best-effort mode checked and exceptions handled within copy_out func
				fi
				
			elif [ -d "$src/$subfile" ]
			then
				# it's a directory ($subfile) within that directory
				# which has to be taken own ($src).
				
				# now, it's either ours ($subfile) and parent ($src) is writable,
				# then it can be moved almost directly;
				# or else it has be taken own as well.
				
				if [ "$owner" = "$UID" -a $is_writable_src = yes ]
				then
					# directories must be writable in order to be moved
					# into an other parent directory.
					# so temporary allow the current user to write her
					# own directory ($subfile) to able to move it.
					
					local modes=`stat -c %a "$src/$subfile"`
					run chmod u+w "$src/$subfile" || [ -w "$src/$subfile" ]
					local moved
					if run verbose mv --force --no-target-directory "$src/$subfile" "$trg/$subfile"
					then
						moved=yes
						# restore permission modes on $subfile (now it's in $trg directory)
						run chmod 0$modes "$trg/$subfile"
						register_moved_file "$src/$subfile" "$trg/$subfile"
					else
						moved=no
						# restore permission modes on $subfile (stayd in $src directory)
						run chmod 0$modes "$src/$subfile"
					fi
					
					# assert the move was successful
					test $moved = yes -o $besteffort = yes
				else
					# this directory ($subfile) can not be moved,
					# let's takeown.
					takeown_directory_recursive "$src/$subfile" "$trg/$subfile" "" no
					# best-effort mode is checked recursively
				fi
			
			elif [ "$owner" = "$UID" -a $is_writable_src = yes ]
			then
				if run verbose mv --force --no-target-directory "$src/$subfile" "$trg/$subfile"
				then
					register_moved_file "$src/$subfile" "$trg/$subfile"
				else
					# either 'mv' should succeed or we should be in best-effort mode
					besteffort_mode
				fi
			else
				copy_out file "$src/$subfile" "$trg/$subfile"
				# best-effort mode checked and exceptions handled within copy_out func
			fi
		done
	fi
	
	# clone attributes of the directory taken own just now
	# as we finished writing into it.
	copy_attributes "$src" "$trg"
	# best-effort mode checked and exceptions handled within copy_attributes func
	
	# actually rename the owned directory
	# to the one which is wanted to be taken own.
	if [ "$do_supersede" = yes ]
	then
		# make a backup
		if [ -n "$src_back" ]
		then
			if ! is_empty_directory "$src"
			then
				run verbose mv --force --no-target-directory "$src" "$src_back"
			fi
		fi
		
		# final step to takeown
		run verbose mv --force --no-target-directory "$trg" "$src"
	fi
}

takeown_directory()
{
	local do_supersede=yes
	
	try --except "cleanup directory"
		takeown_directory_recursive "$TAKEOWN_FILE" "$TAKEOWN_COPY" "$TAKEOWN_BACK" $do_supersede
	untry
}



shopt -s dotglob
shopt -s nullglob

PROGNAME=takeown
verbose=''
debug=''
dryrun=''
recursive=''
declare -A strict
strict=([mode]='' [group]='' [acl]='' [xattr]='')
dochgrp=yes
ignoreerrors=''
activewritetest=''
silent_strictness_check=no
erase_on_fail=no
besteffort=no


while [ -n "$1" ]
do
	case "$1" in
	-h|--help)
		echo "Usage: takeown [options] <files>
Options:
 -D, --debug               debug
 -v, --verbose             verbose
 -n, --dry-run             dry run
 -i, --ignore              ignore failures on files given in command arguments
 -b, -I, --best-effort     ignore any failure while recursing (imply -i)
 -R, --recursive           recurse into directories
 -t, --strict              strict chmod, chgrp, setfacl, setfattr
 -M, --no-strict-chmod     different mode does not matter
 -G, --no-strict-chgrp     different group does not matter
 -A, --no-strict-setfacl   different ACL does not matter
 -X, --no-strict-setfattr  different extended attributes do not matter
 -g, --no-chgrp            do not chgrp at all
 -w, --active-write-test   active write test (instead of access(2))
 --erase-on-failure        remove copies when taking own a directory is failed
Exit code:
 0    all operations succeeded
 1+   error happended during progress, even it was ignored"
		exit 0
		;;
	-v|--verbose)
		verbose=yes
		;;
	-D|--debug)
		debug=yes
		;;
	-n|--dry-run)
		dryrun=yes
		;;
	--erase-on-fail|--erase-on-failure)
		erase_on_fail=yes
		;;
	-R|--recursive)
		recursive=yes
		;;
	-g|--no-group|--no-chgrp)
		dochgrp=no
		;;
	-i|--ignore)
		ignoreerrors=yes
		;;
	-b|-I|--best-effort)
		besteffort=yes
		;;
	-t|--strict)
		for s in ${!strict[@]}
		do
			[ -z "${strict[$s]}" ] && strict[$s]=yes
		done
		;;
	-M|--no-strict-mode|--no-strict-modes|--no-strict-chmod)
		strict[mode]=no
		;;
	-G|--no-strict-group|--no-strict-chgrp)
		strict[group]=no
		;;
	-A|--no-strict-acl|--no-strict-setfacl)
		strict[acl]=no
		;;
	-X|--no-strict-xattr|--no-strict-setfattr)
		strict[xattr]=no
		;;
	-w|--active-write-test)
		activewritetest=yes
		;;
	-*)
		errx 1 "Unknown option: $1"
		;;
	--)
		shift
		break
		;;
	*)
		break
		;;
	esac
	shift
done

declare -g Error=0
# these arrays keep track of recursive directory takeown process.
declare -a files_copied_out_src
declare -a files_copied_out_trg
declare -a files_moved_out_src
declare -a files_moved_out_trg
declare -a dirs_created

main "$@"
exit $Error



true <<EOF

=pod

=encoding utf8

=head1 NAME

takeown - Take ownership on files, even for unprivileged users

=head1 SYNOPSIS

takeown [I<options>] <I<files> and I<directories>>

=head1 DESCRIPTION

chown(2) is permitted only for root (and processes with CAP_CHOWN), but normal users can imitate this behavior.
You can copy other users´ file for your own in a directory writable by you, and then replace the original file with your copy.
It is quite tricky and maybe expensive (copying huge files), but gives you an option.
Say, when somebody forgot to use the right user account when saving files directly to your folders.

=head1 TECH REFERENCE

=head2 Call stack

 script --> main --> takeown
                     /  |  \
                    /   |   \
                   /    |    \
           takeown   takeown  takeown
           _file    _symlink  _directory
             |         |           |
 - - - - - - | - - - - | - - - - - | - - - - - - - - - - - - - -
 error       |         |           |
 handler     |         |           V         ,---> register_created_dir
 function:   |         |  ,--> takeown       |
 cleanup     |         |  |    _directory ---+---> register_moved_file
             |         |  |    _recursive    |
             |         |  |      | |     \   `---> register_
             |         |  `------´ |      \    ,-> copied_file
             |         V           V       \   |
             |      copy_out <-- copy_out --\--'
             |      _symlink     /           \
             V                  /            |
         copy_out <------------´             |
           _file                             |
             |                               |
             `-------> copy_attributes <-----´

=cut

EOF
