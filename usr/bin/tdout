#!/usr/bin/env perl5.18-or-later

use Data::Dumper;
use Getopt::Long;
use Perl::Tokenizer;

do $ENV{'PERL5LIB_ROOT'}."/usr/lib/tdat/common.pl" or die "$@: $!";

$skip_output_headers = 0;
$excludelist = 0;

GetOptions(
	'F=s' => \$IFS,
	'S=s' => \$OFS,
	'n' => \$skip_output_headers,
	'x' => \$excludelist,
) or
die "Usage: $0 [<OPTIONS>] [--] [-]<COLUMN> [[-]<COLUMN> [...]]
OPTIONS:
  -F REGEX   input field separator (default: /$IFS/)
  -S STRING  output field separator (default: ".vardump($OFS).")
  -n         do not output headers
COLUMN is the column's name to be shown, in order. If COLUMN is prefixed
by a minus sign (\"-\") then all columns are shown except COLUMN.
";


my $header = <STDIN>;
my @INPUT_COLUMNS = parse_column_headers($header);
undef $header;

$\ = "\n";


my @OUTPUT_COLUMNS;
# check if either all columns
if(scalar @ARGV > 0)
{
	if((all map {/^-/} @ARGV) or (all map {!/^-/} @ARGV)) {}
	else { die "Do not mix column inclusion and exclusion."; }
}
if($ARGV[0] =~ /^-/)
{
	my @exclude = map {substr $_, 1} @ARGV;
	@OUTPUT_COLUMNS = grep { not $_ ~~ @exclude } @INPUT_COLUMNS;
}
else
{
	@OUTPUT_COLUMNS = @ARGV;
}


if(not $skip_output_headers)
{
	print join $OFS, @OUTPUT_COLUMNS;
}


# process input
while(<STDIN>)
{
	my %FIELD = parse_record($_, @INPUT_COLUMNS);
	my @output_fields = ();
	
	for my $expr (@OUTPUT_EXPR)
	{
		my $field_value = eval $expr;
		die $@ if $@;
		push @output_fields, $field_value;
	}
	print join $OFS, @output_fields;
}
