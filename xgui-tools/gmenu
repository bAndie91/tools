#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from __future__ import print_function

import os
import sys
import re
import gtk
import glib
import glob


# it'd be nice if i could remove the left-side padding where the
# ImageMenuItem icons are used to be, but it's unneccessary because i
# implemented menu icons separately (to put icons to HeaderMenuItem too
# which needs to be a SeparatorMenuItem to prevent activation)
gtk.settings_get_default().set_property("gtk-menu-images", False)


def exit():
	gtk.main_quit()

def unescape_path_element(x):
	return re.sub(r'\\(.)', lambda m: m.group(1), x)

def pathsplit(path):
	elements = []
	pairs = ['' if x is None else x for x in re.split(r'(?<!\\)(\\\\)*/', path) + [None]]
	for i in range(0, len(pairs), 2):
		elements.append(pairs[i] + pairs[i+1])
	return ['/'.join(elements[0:-1]), elements[-1]]


def icondir2size(path):
	match = re.findall(r'/([0-9]+)x[0-9]+', path)
	if not match: return -1
	return match[0]

def find_icon_file(iconname, preferred_size_px):
	dirs = []
	for categ in 'hicolor', 'locolor', 'gnome':
		directory = os.path.join('/usr/share/icons/', categ)
		small = []
		for icondir in sorted(glob.glob(directory+'/*x*/*'), key = icondir2size):
			if icondir2size(icondir) < preferred_size_px:
				small.insert(0, icondir)
			else:
				dirs.append(icondir)
		dirs.append(directory+'/scalable/*')
		dirs.extend(small)
	dirs.append('/usr/share/pixmaps')
	
	for icondir in dirs:
		iconpath_test = None
		for ext in 'png', 'xpm', 'svg':
			if iconname.find(os.path.extsep):
				iconpath_test = os.path.join(icondir, iconname)
			else:
				iconpath_test = os.path.join(icondir, iconname) + os.path.extsep + ext
			if os.path.exists(iconpath_test):
				return iconpath_test
			if iconname.find(os.path.extsep):
				break


class Menu(gtk.Menu):
	def __init__(self):
		super(Menu, self).__init__()
		self.submenuitems = []
	def main_popup(self):
		self.popup(None, None, None, 0, gtk.get_current_event_time())
	def get_submenu(self):
		return self
	def register_child(self, mi):
		self.submenuitems.append(mi)
	def __repr__(self):
		return "<%s path='%s'>" %(self.__class__.__name__, self.labelpath)


class MenuItem(gtk.MenuItem):
	def __init__(self, labelpath):
		assert labelpath != ''
		super(MenuItem, self).__init__()
		parent_label, label = pathsplit(labelpath)
		self.labelpath = labelpath
		self.parent_label = parent_label
		self.label = unescape_path_element(label)
		self.submenuitems = []
		self.icon = None
	def __repr__(self):
		return "<%s label='%s' path='%s' icon=%s>" %(self.__class__.__name__, self.label, self.labelpath, repr(self.icon))
	def register_child(self, mi):
		self.submenuitems.append(mi)

class IconMenuItem(MenuItem):
	def __init__(self, labelpath):
		super(IconMenuItem, self).__init__(labelpath)
		inner_widget = gtk.HBox(homogeneous=False, spacing=5) #TODO get spacing from theme
		self.label_widget = gtk.Label()
		self.label_widget.set_alignment(0, 0.5)
		self.label_widget.set_use_underline(False)
		self.icon_widget = gtk.Image()
		self.icon_widget.set_size_request(*gtk.icon_size_lookup(gtk.ICON_SIZE_MENU))
		inner_widget.pack_start(self.icon_widget, False, False, 0)
		inner_widget.pack_start(self.label_widget, True, True, 0)
		self.add(inner_widget)
	@property
	def label_markup(self):
		return self.label_widget.get_markup()
	@label_markup.setter
	def label_markup(self, markup):
		self.label_widget.set_markup(markup)
		self.label_widget.set_use_markup(True)
		return self
	@property
	def label_plaintext(self):
		return self.label_widget.get_text()
	@label_plaintext.setter
	def label_plaintext(self, plaintext):
		self.label_widget.set_text(plaintext)
		self.label_widget.set_use_markup(False)
		return self
	@property
	def icon(self):
		return self._icon
	@icon.setter
	def icon(self, icon):
		if not icon: return
		if icon.startswith(os.path.sep):
			self.icon_widget.set_from_file(icon)
		elif icon in gtk.stock_list_ids():
			self.icon_widget.set_from_stock(icon, gtk.ICON_SIZE_MENU)
		elif gtk.icon_theme_get_default().lookup_icon(icon, gtk.ICON_SIZE_MENU, 0) is not None:
			self.icon_widget.set_from_icon_name(icon, gtk.ICON_SIZE_MENU)
		else:
			self.icon_widget.set_from_file(find_icon_file(icon, gtk.icon_size_lookup(gtk.ICON_SIZE_MENU)[0]))
		self._icon = icon
		return self

class ParentMenuItem(IconMenuItem):
	def __init__(self, labelpath):
		super(ParentMenuItem, self).__init__(labelpath)
		self.label_plaintext = self.label

class ResponseTextMenuItem(ParentMenuItem):
	def __init__(self, labelpath):
		super(ResponseTextMenuItem, self).__init__(labelpath)
		self._responsetext = ''
		self.connect('activate', self.on_activate)
	def on_activate(self, *X):
		if not self.get_submenu():
			print(self._responsetext)
			exit()
	@property
	def responsetext(self):
		return self._responsetext
	@responsetext.setter
	def responsetext(self, responsetext):
		self._responsetext = responsetext
		return self

class SeparatorMenuItem(gtk.SeparatorMenuItem, MenuItem):
	def __init__(self, labelpath):
		super(SeparatorMenuItem, self).__init__()
		MenuItem.__init__(self, labelpath)

class HeaderMenuItem(SeparatorMenuItem, IconMenuItem):
	def __init__(self, labelpath):
		super(HeaderMenuItem, self).__init__(labelpath)
		IconMenuItem.__init__(self, labelpath)
		self.label_markup = '<b><span size="large">' + glib.markup_escape_text(self.label) + '</span></b>'



def get_menuitem(labelpath, cls=ParentMenuItem):
	# TODO support equivalent labels on the same level
	if labelpath in menuitem_by_labelpath:
		return menuitem_by_labelpath[labelpath]
	
	if labelpath == '':
		mi = Menu()
		mi.labelpath = labelpath
	else:
		mi = cls(labelpath)
	menuitem_by_labelpath[labelpath] = mi
	if labelpath != '':
		get_menuitem(mi.parent_label).register_child(mi)
	return mi

def add_registered_submenuitems_recursively(mi):
	for child in mi.submenuitems:
		submenu = mi.get_submenu()
		if submenu is None:
			submenu = Menu()
			submenu.labelpath = mi.labelpath
			mi.set_submenu(submenu)
		submenu.append(child)
		add_registered_submenuitems_recursively(child)



menuitem_by_labelpath = {}

while True:
	line = sys.stdin.readline()
	if line == '': break
	if line[-1] == '\n': line = line[:-1]  # chomp
	if line == '': continue
	
	words = line.split('\t', 3)
	labelpath, tipus, icon, responsetext = words + ['']*(4-len(words))
	if tipus == '': tipus = 'responsetext'
	if responsetext == '': responsetext = labelpath
	
	mi = None
	if tipus == 'sep':
		mi = get_menuitem(labelpath, SeparatorMenuItem)
	elif tipus == 'header':
		mi = get_menuitem(labelpath, HeaderMenuItem)
	elif tipus == 'responsetext':
		mi = get_menuitem(labelpath, ResponseTextMenuItem)
	else:
		print("unknown menu item type: "+tipus, file=sys.stderr)
	
	if mi is not None:
		mi.responsetext = responsetext
		mi.icon = icon

if '' not in menuitem_by_labelpath:
	get_menuitem("no menu items", HeaderMenuItem)

main_menu = menuitem_by_labelpath['']
main_menu.connect('deactivate', lambda *X: exit())
add_registered_submenuitems_recursively(main_menu)
main_menu.show_all()
main_menu.main_popup()
gtk.main()
