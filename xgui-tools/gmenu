#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from __future__ import print_function

import os
import sys
import re
import gtk
import glib
import glob

from hband_tools.gui import *


# it'd be nice if i could remove the left-side padding where the
# ImageMenuItem icons normally are, but those are unneccessary because
# i implemented menu icons separately to put icons to HeaderMenuItem too
# (which needs to be a SeparatorMenuItem to prevent activation)
#gtk.settings_get_default().set_property("gtk-menu-images", False)


def exit():
	gtk.main_quit()

def unescape_path_element(x):
	return re.sub(r'\\(.)', lambda m: m.group(1), x)

def pathsplit(path):
	elements = []
	pairs = ['' if x is None else x for x in re.split(r'(?<!\\)(\\\\)*/', path) + [None]]
	for i in range(0, len(pairs), 2):
		elements.append(pairs[i] + pairs[i+1])
	return ['/'.join(elements[0:-1]), elements[-1]]


class Menu(gtk.Menu):
	def __init__(self):
		super(Menu, self).__init__()
		self.submenuitems = []
	def main_popup(self):
		self.popup(None, None, None, 0, gtk.get_current_event_time())
	def get_submenu(self):
		return self
	def register_child(self, mi):
		self.submenuitems.append(mi)
	def __repr__(self):
		return "<%s path='%s'>" %(self.__class__.__name__, self.labelpath)


class MenuItem(gtk.MenuItem):
	def __init__(self, labelpath):
		assert labelpath != ''
		super(MenuItem, self).__init__()
		parent_label, label = pathsplit(labelpath)
		self.labelpath = labelpath
		self.parent_label = parent_label
		self.label = unescape_path_element(label)
		self.submenuitems = []
		self.icon = None
	def __repr__(self):
		return "<%s label='%s' path='%s' icon=%s>" %(self.__class__.__name__, self.label, self.labelpath, repr(self.icon) if hasattr(self, 'icon') else 'None')
	def register_child(self, mi):
		self.submenuitems.append(mi)

class IconMenuItem(MenuItem):
	def __init__(self, labelpath):
		super(IconMenuItem, self).__init__(labelpath)
		inner_widget = gtk.HBox(homogeneous=False, spacing=5) #TODO get spacing from toggle-spacing style prop
		self.label_widget = gtk.Label()
		self.label_widget.set_alignment(0, 0.5)
		self.label_widget.set_use_underline(False)
		self.icon_widget = gtk.Image()
		self.icon_widget.set_size_request(*gtk.icon_size_lookup(gtk.ICON_SIZE_MENU))
		inner_widget.pack_start(self.icon_widget, False, False, 0)
		inner_widget.pack_start(self.label_widget, True, True, 0)
		self.add(inner_widget)
	@property
	def label_markup(self):
		return self.label_widget.get_markup()
	@label_markup.setter
	def label_markup(self, markup):
		self.label_widget.set_markup(markup)
		self.label_widget.set_use_markup(True)
		return self
	@property
	def label_plaintext(self):
		return self.label_widget.get_text()
	@label_plaintext.setter
	def label_plaintext(self, plaintext):
		self.label_widget.set_text(plaintext)
		self.label_widget.set_use_markup(False)
		return self
	@property
	def icon(self):
		return self._icon
	@icon.setter
	def icon(self, icon):
		if not icon: return
		if os.path.isfile(icon):
			width_px, height_px = self.icon_widget.get_size_request()[:]
			pixbuf = get_pixbuf_from_file_at_size(icon, width_px, height_px)
			self.icon_widget.set_from_pixbuf(pixbuf)
		elif icon in gtk.stock_list_ids():
			self.icon_widget.set_from_stock(icon, gtk.ICON_SIZE_MENU)
		elif gtk.icon_theme_get_default().lookup_icon(icon, gtk.ICON_SIZE_MENU, 0) is not None:
			self.icon_widget.set_from_icon_name(icon, gtk.ICON_SIZE_MENU)
		else:
			width_px, height_px = self.icon_widget.get_size_request()[:]
			iconfile = find_icon_file(icon, width_px)
			if iconfile is not None:
				pixbuf = get_pixbuf_from_file_at_size(iconfile, width_px, height_px)
				self.icon_widget.set_from_pixbuf(pixbuf)
		self._icon = icon
		return self

class ParentMenuItem(IconMenuItem):
	def __init__(self, labelpath):
		super(ParentMenuItem, self).__init__(labelpath)
		self.label_plaintext = self.label

class ResponseTextMenuItem(ParentMenuItem):
	def __init__(self, labelpath):
		super(ResponseTextMenuItem, self).__init__(labelpath)
		self._responsetext = ''
		self.connect('activate', self.on_activate)
	def on_activate(self, *X):
		if not self.get_submenu():
			print(self._responsetext)
			exit()
	@property
	def responsetext(self):
		return self._responsetext
	@responsetext.setter
	def responsetext(self, responsetext):
		self._responsetext = responsetext
		return self

class SeparatorMenuItem(gtk.SeparatorMenuItem, MenuItem):
	def __init__(self, labelpath):
		super(SeparatorMenuItem, self).__init__()
		MenuItem.__init__(self, labelpath)

class HeaderMenuItem(SeparatorMenuItem, IconMenuItem):
	def __init__(self, labelpath):
		super(HeaderMenuItem, self).__init__(labelpath)
		IconMenuItem.__init__(self, labelpath)
		self.label_markup = '<b><span size="large">' + glib.markup_escape_text(self.label) + '</span></b>'
		
		# an other trick to prevent HeaderMenuItem to be activatable is to set to insensitive
		# but render it like STATE_NORMAL visually (set the foreground color to that of normal fg and white_gc to background color)
		# however images on insensitive widgets are also rendered in gray, which is hard to restore.
		#self.set_sensitive(False)
		# keep the insensitive state the same style as the active (sensitive) state
		#for prop in ['fg', 'bg', 'text', 'base']:
		#	getattr(self.label_widget, 'modify_'+prop)(gtk.STATE_INSENSITIVE, getattr(self.label_widget.get_style(), prop)[gtk.STATE_NORMAL])
		#self.label_widget.modify_white_gc(gtk.STATE_INSENSITIVE, self.label_widget.get_style().white_gc[gtk.STATE_NORMAL])



def get_menuitem(labelpath, cls=ParentMenuItem):
	if cls == ParentMenuItem:
		if labelpath in menuitem_by_labelpath:
			return menuitem_by_labelpath[labelpath]
	
	if labelpath == '':
		mi = Menu()
		mi.labelpath = labelpath
	else:
		mi = cls(labelpath)
	menuitem_by_labelpath[labelpath] = mi
	if labelpath != '':
		get_menuitem(mi.parent_label).register_child(mi)
	return mi

def add_registered_submenuitems_recursively(mi):
	for child in mi.submenuitems:
		submenu = mi.get_submenu()
		if submenu is None:
			submenu = Menu()
			submenu.labelpath = mi.labelpath
			mi.set_submenu(submenu)
		submenu.append(child)
		add_registered_submenuitems_recursively(child)



menuitem_by_labelpath = {}

while True:
	line = sys.stdin.readline()
	if line == '': break
	if line[-1] == '\n': line = line[:-1]  # chomp
	if line == '': continue
	
	words = line.split('\t', 3)
	labelpath, tipus, icon, responsetext = words + ['']*(4-len(words))
	if tipus == '': tipus = 'responsetext'
	if responsetext == '': responsetext = labelpath
	
	mi = None
	if tipus == 'sep':
		mi = get_menuitem(labelpath, SeparatorMenuItem)
	elif tipus == 'header':
		mi = get_menuitem(labelpath, HeaderMenuItem)
	elif tipus == 'responsetext':
		mi = get_menuitem(labelpath, ResponseTextMenuItem)
	else:
		print("unknown menu item type: "+tipus, file=sys.stderr)
	
	if mi is not None:
		mi.responsetext = responsetext
		mi.icon = icon

if '' not in menuitem_by_labelpath:
	get_menuitem("no menu items", HeaderMenuItem)

main_menu = menuitem_by_labelpath['']
main_menu.connect('deactivate', lambda *X: exit())
add_registered_submenuitems_recursively(main_menu)
main_menu.show_all()
main_menu.main_popup()
gtk.main()
