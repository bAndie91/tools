#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

import os
import sys
import signal
import gtk
import gobject
import glib
import pango
import gettext
import re
import time
from datetime import datetime
from dateutil.relativedelta import relativedelta


def win_main_show():
	pass


def act_quit():
	if len(running_timers()) > 0:
		pass
	else:
		gtk.main_quit()
	return True


def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)


class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None, tooltip=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True



class Clock(gtk.Label):
	name = "Clock"
	
	def __init__(self):
		super(gtk.Label, self).__init__()
		self._format = '%H:%M:%S'
		self._running = False
		self._draining = False
		self._update()
	
	@property
	def display(self):
		return time.strftime(self._format, time.localtime(time.time()))
	
	@property
	def is_running(self):
		return self._running
	
	def _next_update_interval_ms(self):
		now = time.time()
		nextsecond = 1 - (now - int(now))
		return int(nextsecond * 1000)
	
	def update_display(self):
		self.set_markup("<span size='32000'><b>" + self.display + "</b></span>")
	
	def _update(self):
		if not self._draining:
			self.update_display()
			glib.timeout_add(self._next_update_interval_ms(), self._update, priority=glib.PRIORITY_DEFAULT_IDLE)
		return False


class Stopper(Clock):
	name = "Stopper"
	
	__gsignals__ = {
		'started': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, ()),
		'paused': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, ()),
	}
	
	def __init__(self):
		self._start_time = 0
		self._behind_interval = 0
		self._running = False
		self._last_paused_time = 0
		super(self.__class__, self).__init__()
	
	def run(self):
		if not self._running:
			now = time.time()
			if self._start_time == 0:
				self._start_time = now
			if self._last_paused_time > 0:
				self._behind_interval += now - self._last_paused_time
			self._running = True
			self.emit('started')
			self._update()
	
	def pause(self):
		if self._running:
			self._last_paused_time = time.time()
			self._running = False
			self.emit('paused')
			self._update()
	
	def _next_update_interval_ms(self):
		return 10
	
	@property
	def display(self):
		if self._start_time > 0:
			if self._running:
				display_time = time.time() - self._start_time - self._behind_interval
			else:
				display_time = self._last_paused_time - self._start_time - self._behind_interval
			hours = display_time / 3600
			return '%s%02d:%02d.%02d' % (
				('%dh ' % hours) if hours >= 1 else '', 
				display_time / 60 % 60, 
				display_time % 60, 
				(display_time - int(display_time)) * 100,
			)
		else:
			return '--:--.--'


class SpinLabel(gtk.EventBox):
	def __init__(self, format, start_value):
		self.format = format
		self._value = start_value
		self._locked = False
		self.range = (0, 59)
		self.label = gtk.Label()
		super(self.__class__, self).__init__()
		self.add(self.label)
		self.connect('scroll-event', self._event_scroll)
		self.show_all()
		self._update_label()
	def __str__(self):
		return str(self._value)
	def __int__(self):
		return self._value
	@property
	def value(self):
		return self._value
	@value.setter
	def value(self, x):
		x = int(x)
		if x > self.range[1]: x = self.range[0]
		if x < self.range[0]: x = self.range[1]
		self._value = x
		self._update_label()
	def lock(self):
		self._locked = True
	def unlock(self):
		self._locked = False
	def _event_scroll(self, X, event):
		if self._locked: return
		delta = +1 if event.direction == gtk.gdk.SCROLL_UP else -1
		self.value += delta
	def _update_label(self):
		self.label.set_markup(self.format % self._value)

class KitchenTimer(gtk.HBox, Clock):
	name = "Timer"
	
	__gsignals__ = {
		'started': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, ()),
		'due': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, ()),
	}
	
	def __init__(self):
		fmt = "<span size='32000'><b>%s</b></span>"
		self.hours = SpinLabel(fmt % '%d:', 0)
		self.minutes = SpinLabel(fmt % '%02d:', 0)
		self.seconds = SpinLabel(fmt % '%02d', 0)
		self.alarmed = False
		super(gtk.HBox, self).__init__()
		super(Clock, self).__init__()
		self.pack_start(self.hours, expand=False, fill=False)
		self.pack_start(self.minutes, expand=False, fill=False)
		self.pack_start(self.seconds, expand=False, fill=False)
		self.show_all()
	
	@property
	def scheduled_time(self):
		return int(self.hours) * 3600 + int(self.minutes) * 60 + int(self.seconds)
	
	def start(self):
		if not self._running:
			self.scheduled_hours = int(self.hours)
			self.scheduled_minutes = int(self.minutes)
			self.scheduled_seconds = int(self.seconds)
			self.hours.lock()
			self.minutes.lock()
			self.seconds.lock()
			self._future_time = time.time() + self.scheduled_time
			self._running = True
			self.emit('started')
	
	def stop(self):
		if self.alarmed:
			self._running = False
	
	def alarm(self):
		message = "Timer Alarm"
		dialog = gtk.MessageDialog(flags=gtk.DIALOG_DESTROY_WITH_PARENT, type=gtk.MESSAGE_WARNING, buttons=gtk.BUTTONS_OK, message_format=message)
		dialog.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_TOOLBAR)
		dialog.set_keep_above(True)
		dialog.set_skip_taskbar_hint(False)
		dialog.set_icon_name('alarm-clock')
		dialog.set_title(message)
		dialog.format_secondary_text("Your %d:%02d:%02d timer is due!" % (self.scheduled_hours, self.scheduled_minutes, self.scheduled_seconds))
		btn_ok = dialog.get_widget_for_response(gtk.RESPONSE_OK)
		btn_ok.connect('clicked', lambda *X: dialog.destroy())
		dialog.show_all()
		win_main.present()
		dialog.present()
	
	@property
	def display(self):
		return ''
	
	def update_display(self):
		if self._running:
			display_time = self._future_time - time.time()
			if display_time <= 0:
				if not self.alarmed:
					self.emit('due')
					self.alarm()
					self.alarmed = True
				
				fmt = "<span size='32000' foreground='red'><b>%s</b></span>"
				self.hours.format = fmt % '-%d:'
				self.minutes.format = fmt % '%02d:'
				self.seconds.format = fmt % '%02d'
			self.hours.value = abs(display_time) / 3600
			self.minutes.value = abs(display_time) / 60 % 60
			self.seconds.value = abs(display_time) % 60


class StopperUI(gtk.HBox):
	name = Stopper.name
	
	def __init__(self, *pargs, **kwargs):
		super(gtk.HBox, self).__init__(*pargs, **kwargs)
		self.stopper = Stopper()
		self.btn_start = StockButton(stock=gtk.STOCK_MEDIA_PLAY, label='')
		self.btn_pause = StockButton(stock=gtk.STOCK_MEDIA_PAUSE, label='')
		self.btn_start.connect('clicked', lambda *X: self.stopper.run())
		self.btn_pause.connect('clicked', lambda *X: self.stopper.pause())
		self.pack_start(self.stopper, expand=True, fill=True)
		self.pack_start(self.btn_start, expand=False, fill=False)
		self.pack_start(self.btn_pause, expand=False, fill=False)
		
		self.stopper.connect('started', lambda *X: self.manage_button_states())
		self.stopper.connect('paused', lambda *X: self.manage_button_states())
		self.manage_button_states()
	
	def manage_button_states(self):
		running = self.stopper.is_running
		self.btn_start.set_sensitive(not running)
		self.btn_pause.set_sensitive(running)
	
	@property
	def is_running(self):
		return self.stopper.is_running
	
	def drain(self):
		self.stopper._draining = True


class KitchenTimerUI(gtk.HBox):
	name = KitchenTimer.name
	
	def __init__(self, *pargs, **kwargs):
		super(gtk.HBox, self).__init__(*pargs, **kwargs)
		self.timer = KitchenTimer()
		self.btn_start = StockButton(stock=gtk.STOCK_MEDIA_PLAY, label='')
		self.btn_start.connect('clicked', lambda *X: self.timer.start())
		self.btn_stop = StockButton(stock=gtk.STOCK_MEDIA_STOP, label='')
		self.btn_stop.connect('clicked', lambda *X: self.timer.stop())
		self.pack_start(self.timer, expand=True, fill=True)
		self.pack_start(self.btn_start, expand=False, fill=False)
		self.pack_start(self.btn_stop, expand=False, fill=False)
		
		self.timer.connect('started', lambda *X: self.manage_button_states())
		self.manage_button_states()
	
	def manage_button_states(self):
		running = self.timer.is_running
		self.btn_start.set_sensitive(not running)
	
	@property
	def is_running(self):
		return self.timer._running
	
	def drain(self):
		self.timer._draining = True


class MultiBox(gtk.VBox):
	def __init__(self, klass):
		super(gtk.VBox, self).__init__()
		self._items = []
		self._klass = klass
		plusbutton = StockButton(stock=gtk.STOCK_ADD, label=klass.name)
		plusbutton.connect('clicked', lambda *x: self.new_item())
		self.pack_start(plusbutton, expand=False, fill=False)
		self.new_item()
	def new_item(self):
		item = self._klass()
		self._items.append(item)
		hbox = gtk.HBox()
		hbox.multibox_item = item
		button_remove = StockButton(stock=gtk.STOCK_REMOVE, label='')
		button_remove.connect('clicked', lambda X, hbox: self.remove_item(hbox), hbox)
		self.pack_start(hbox, expand=False, fill=False)
		hbox.pack_start(item, expand=True, fill=True)
		hbox.pack_start(button_remove, expand=False, fill=False)
		self.show_all()
	@property
	def items(self):
		return self._items
	def remove_item(self, hbox):
		item = hbox.multibox_item
		self.items.remove(item)
		item.drain()
		item.destroy()
		hbox.destroy()


def running_timers():
	return [item for item in mb_stoppers.items + mb_kitchentimers.items if item.is_running]


win_main = gtk.Window(gtk.WINDOW_TOPLEVEL)
box0 = gtk.HBox()
box_clocks = gtk.VBox()
box_stoppers = gtk.VBox()
box_kitchentimers = gtk.VBox()

win_main.set_size_request(700, -1)
win_main.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_TOOLBAR)
win_main.set_keep_above(True)
win_main.set_icon_name('alarm-clock')

start_evt = win_main.connect('map-event', lambda w,e: (win_main.disconnect(start_evt), win_main_show()))
win_main.connect('delete-event', lambda w,e: act_quit())
add_key_binding(win_main, '<Ctrl><Shift>Q', lambda *x: act_quit())

win_main.add(box0)
box0.pack_start(MultiBox(Clock), expand=True, fill=False)
mb_stoppers = MultiBox(StopperUI)
mb_kitchentimers = MultiBox(KitchenTimerUI)
box0.pack_start(mb_stoppers, expand=True, fill=False)
box0.pack_start(mb_kitchentimers, expand=True, fill=False)
win_main.show_all()

gtk.main()
